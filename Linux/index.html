



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="A Material Design theme for MyNotes">
      
      
      
        <meta name="author" content="Anonymous">
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../images/favicon.ico">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.0.1">
    
    
      
        <title>Linux - Material Design for MyNotes</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.982221ab.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-palette.224b79ff.css">
      
      
        
        
        <meta name="theme-color" content="#4caf50">
      
    
    
      <script src="../assets/javascripts/modernizr.1f0bcf2b.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
      <link rel="manifest" href="../manifest.webmanifest">
    
    
    
      
        
<script>
  window.ga = window.ga || function() {
    (ga.q = ga.q || []).push(arguments)
  }
  ga.l = +new Date
  /* Setup integration and send page view */
  ga("create", "UA-131093963-1", "auto")
  ga("set", "anonymizeIp", true)
  ga("send", "pageview")
  /* Register handler to log search on blur */
  document.addEventListener("DOMContentLoaded", () => {
    if (document.forms.search) {
      var query = document.forms.search.query
      query.addEventListener("blur", function() {
        if (this.value) {
          var path = document.location.pathname;
          ga("send", "pageview", path + "?q=" + this.value)
        }
      })
    }
  })
</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="green" data-md-color-accent="light-green">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448"
    viewBox="0 0 416 448" id="__github">
  <path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19-18.125
        8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19 18.125-8.5
        18.125 8.5 10.75 19 3.125 20.5zM320 304q0 10-3.125 20.5t-10.75
        19-18.125 8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19
        18.125-8.5 18.125 8.5 10.75 19 3.125 20.5zM360
        304q0-30-17.25-51t-46.75-21q-10.25 0-48.75 5.25-17.75 2.75-39.25
        2.75t-39.25-2.75q-38-5.25-48.75-5.25-29.5 0-46.75 21t-17.25 51q0 22 8
        38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0
        37.25-1.75t35-7.375 30.5-15 20.25-25.75 8-38.375zM416 260q0 51.75-15.25
        82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5-41.75
        1.125q-19.5 0-35.5-0.75t-36.875-3.125-38.125-7.5-34.25-12.875-30.25-20.25-21.5-28.75q-15.5-30.75-15.5-82.75
        0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25
        30.875q36.75-8.75 77.25-8.75 37 0 70 8 26.25-20.5
        46.75-30.25t47.25-9.75q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34
        99.5z" />
</svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#linux" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href=".." title="Material Design for MyNotes" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              Material Design for MyNotes
            </span>
            <span class="md-header-nav__topic">
              Linux
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/Black-Gold/MyNotes/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Black-Gold/MyNotes
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href=".." title="Material Design for MyNotes" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    Material Design for MyNotes
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/Black-Gold/MyNotes/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Black-Gold/MyNotes
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../Vim/" title="Vim" class="md-nav__link">
      Vim
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      ProgramLanguages
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        ProgramLanguages
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../BREs/" title="BREs" class="md-nav__link">
      BREs
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Shell/" title="Shell" class="md-nav__link">
      Shell
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Python3/" title="Python3" class="md-nav__link">
      Python3
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Lua/" title="Lua" class="md-nav__link">
      Lua
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Go/" title="Go" class="md-nav__link">
      Go
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      AboutLinux
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        AboutLinux
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Linux
      </label>
    
    <a href="./" title="Linux" class="md-nav__link md-nav__link--active">
      Linux
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ubuntu-debian" title="Ubuntu--Debian" class="md-nav__link">
    Ubuntu--Debian
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#debian" title="Debian常见命令" class="md-nav__link">
    Debian常见命令
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#centos" title="Centos" class="md-nav__link">
    Centos
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linuxjava" title="Linux安装java" class="md-nav__link">
    Linux安装java
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" title="分区方案参考" class="md-nav__link">
    分区方案参考
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#centospythonyum" title="centos完全重装python和yum" class="md-nav__link">
    centos完全重装python和yum
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ssh" title="更改默认ssh连接端口" class="md-nav__link">
    更改默认ssh连接端口
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" title="优化内核参数 [根据实际情况调整]" class="md-nav__link">
    优化内核参数 [根据实际情况调整]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#root" title="赋予root权限" class="md-nav__link">
    赋予root权限
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" title="服务器配置双机信任" class="md-nav__link">
    服务器配置双机信任
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-float-ip" title="未采用双机热备防止服务中断--float IP" class="md-nav__link">
    未采用双机热备防止服务中断--float IP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#centosip" title="升级centos内核&amp;更改为静态ip、网卡名称" class="md-nav__link">
    升级centos内核&amp;更改为静态ip、网卡名称
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ssh_1" title="SSH相关命令和配置" class="md-nav__link">
    SSH相关命令和配置
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ssh_2" title="SSH协议无密码登陆设定：" class="md-nav__link">
    SSH协议无密码登陆设定：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sshd_configetcsshsshd_config" title="sshd_config配置详解（/etc/ssh/sshd_config）" class="md-nav__link">
    sshd_config配置详解（/etc/ssh/sshd_config）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ssh_3" title="SSH端口转发" class="md-nav__link">
    SSH端口转发
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" title="本地转发实例" class="md-nav__link">
    本地转发实例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" title="远程转发实例" class="md-nav__link">
    远程转发实例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" title="多主机转发应用实例" class="md-nav__link">
    多主机转发应用实例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" title="动态转发实例" class="md-nav__link">
    动态转发实例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#x" title="X协议转发实例" class="md-nav__link">
    X协议转发实例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linux_1" title="linux磁盘详解" class="md-nav__link">
    linux磁盘详解
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#raid0-1-5-10" title="Raid0 1 5 10详解" class="md-nav__link">
    Raid0 1 5 10详解
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#linux_2" title="Linux文件系统目录介绍" class="md-nav__link">
    Linux文件系统目录介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" title="添加硬盘或分区流程" class="md-nav__link">
    添加硬盘或分区流程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_3" title="linux系统引导流程解析" class="md-nav__link">
    linux系统引导流程解析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grub" title="GRUB配置文件讲解：" class="md-nav__link">
    GRUB配置文件讲解：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_4" title="Linux软件包管理" class="md-nav__link">
    Linux软件包管理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_" title="Linux_用户、组和权限" class="md-nav__link">
    Linux_用户、组和权限
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#r-w-x" title="一、权限：r, w, x" class="md-nav__link">
    一、权限：r, w, x
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" title="二、用户和用户组" class="md-nav__link">
    二、用户和用户组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_5" title="Linux用户管理" class="md-nav__link">
    Linux用户管理
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" title="三、管理命令" class="md-nav__link">
    三、管理命令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" title="四、特殊权限" class="md-nav__link">
    四、特殊权限
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_6" title="Linux进程管理" class="md-nav__link">
    Linux进程管理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux5" title="linux上进程有5种状态" class="md-nav__link">
    linux上进程有5种状态
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shell" title="shell脚本笔记" class="md-nav__link">
    shell脚本笔记
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" title="杀死进程命令例子" class="md-nav__link">
    杀死进程命令例子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" title="统计并杀死僵尸进程例子" class="md-nav__link">
    统计并杀死僵尸进程例子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rss" title="进程按rss排序" class="md-nav__link">
    进程按rss排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1pcputid" title="进程按第1列pcpu排序、tid为线程号" class="md-nav__link">
    进程按第1列pcpu排序、tid为线程号
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" title="按进程消耗内存多少排序" class="md-nav__link">
    按进程消耗内存多少排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_7" title="Linux中查看所有正在运行的进程" class="md-nav__link">
    Linux中查看所有正在运行的进程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux-vmware-tools" title="Linux VMware Tools安装步骤简易版" class="md-nav__link">
    Linux VMware Tools安装步骤简易版
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rm" title="恢复rm误删的文件" class="md-nav__link">
    恢复rm误删的文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_8" title="linux常用日志文件默认路径" class="md-nav__link">
    linux常用日志文件默认路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1gswap" title="增加1G的swap空间" class="md-nav__link">
    增加1G的swap空间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_9" title="Linux备份" class="md-nav__link">
    Linux备份
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_10" title="Linux测试硬盘读写速度" class="md-nav__link">
    Linux测试硬盘读写速度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8" title="获取8位随机字符串" class="md-nav__link">
    获取8位随机字符串
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8_1" title="获取8位随机数字" class="md-nav__link">
    获取8位随机数字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" title="定义一个颜色输出字符串函数" class="md-nav__link">
    定义一个颜色输出字符串函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" title="批量创建用户" class="md-nav__link">
    批量创建用户
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bash" title="简单检测某个进程是否存在的bash小脚本。代码如下" class="md-nav__link">
    简单检测某个进程是否存在的bash小脚本。代码如下
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shell_1" title="shell变量的子串的删除/替换" class="md-nav__link">
    shell变量的子串的删除/替换
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" title="清除大于5天的文件" class="md-nav__link">
    清除大于5天的文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shellcpu" title="shell采集系统cpu 内存 磁盘 网络信息" class="md-nav__link">
    shell采集系统cpu 内存 磁盘 网络信息
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cpu" title="cpu信息采集" class="md-nav__link">
    cpu信息采集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" title="内存采集" class="md-nav__link">
    内存采集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" title="磁盘信息采集" class="md-nav__link">
    磁盘信息采集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" title="网络信息采集" class="md-nav__link">
    网络信息采集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shell_2" title="系统管理的常用shell命令" class="md-nav__link">
    系统管理的常用shell命令
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Utilities/" title="Iproute2&Net-tools" class="md-nav__link">
      Iproute2&Net-tools
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Iptables/" title="Iptables" class="md-nav__link">
      Iptables
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Firewalld/" title="Firewalld" class="md-nav__link">
      Firewalld
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      DevOps
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        DevOps
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Ansible/" title="Ansible" class="md-nav__link">
      Ansible
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Apollo/" title="Apollo" class="md-nav__link">
      Apollo
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      WebServer
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        WebServer
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Nginx/" title="Nginx" class="md-nav__link">
      Nginx
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Apache/" title="Apache&PHP-FPM" class="md-nav__link">
      Apache&PHP-FPM
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Tomcat/" title="Tomcat" class="md-nav__link">
      Tomcat
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../WildFly.md" title="WildFly" class="md-nav__link">
      WildFly
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Caddy/" title="Caddy" class="md-nav__link">
      Caddy
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      OptimisingWebDelivery
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        OptimisingWebDelivery
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Squid/" title="Squid" class="md-nav__link">
      Squid
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Varnish/" title="Varnish" class="md-nav__link">
      Varnish
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Stunnel/" title="Stunnel" class="md-nav__link">
      Stunnel
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../TrafficServer/" title="ApacheTrafficServer" class="md-nav__link">
      ApacheTrafficServer
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-8" type="checkbox" id="nav-8">
    
    <label class="md-nav__link" for="nav-8">
      CI&DC
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-8">
        CI&DC
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Git/" title="Git&GitLab" class="md-nav__link">
      Git&GitLab
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Jenkins/" title="Jenkins" class="md-nav__link">
      Jenkins
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-9" type="checkbox" id="nav-9">
    
    <label class="md-nav__link" for="nav-9">
      Database
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-9">
        Database
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../MySQL/" title="MySQL" class="md-nav__link">
      MySQL
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../MariaDB/" title="MariaDB" class="md-nav__link">
      MariaDB
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Oracle/" title="Oracle" class="md-nav__link">
      Oracle
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Redis/" title="Redis" class="md-nav__link">
      Redis
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Memcached/" title="Memcached" class="md-nav__link">
      Memcached
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../MongoDB/" title="MongoDB" class="md-nav__link">
      MongoDB
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../PostgreSQL/" title="PostgreSQL" class="md-nav__link">
      PostgreSQL
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Cassandra/" title="Cassandra" class="md-nav__link">
      Cassandra
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-10" type="checkbox" id="nav-10">
    
    <label class="md-nav__link" for="nav-10">
      Monitor
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-10">
        Monitor
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Zabbix/" title="Zabbix" class="md-nav__link">
      Zabbix
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Prometheus/" title="Prometheus" class="md-nav__link">
      Prometheus
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Grafana/" title="Grafana" class="md-nav__link">
      Grafana
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Elk/" title="ELKStack" class="md-nav__link">
      ELKStack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Nagios/" title="Nagios" class="md-nav__link">
      Nagios
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../TICK/" title="TICKStack" class="md-nav__link">
      TICKStack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../OpenTSDB/" title="OpenTSDB" class="md-nav__link">
      OpenTSDB
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Monitors/" title="SomelseMonitors" class="md-nav__link">
      SomelseMonitors
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-11" type="checkbox" id="nav-11">
    
    <label class="md-nav__link" for="nav-11">
      LB&HA
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-11">
        LB&HA
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../LVSKeepalived/" title="LVSKeepalived" class="md-nav__link">
      LVSKeepalived
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Haproxy/" title="HAProxy" class="md-nav__link">
      HAProxy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Traefik/" title="Traefik" class="md-nav__link">
      Traefik
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Envoy/" title="Envoy" class="md-nav__link">
      Envoy
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-12" type="checkbox" id="nav-12">
    
    <label class="md-nav__link" for="nav-12">
      ContainerEcosystem
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-12">
        ContainerEcosystem
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Docker/" title="Docker" class="md-nav__link">
      Docker
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Kubernetes/" title="Kubernetes" class="md-nav__link">
      Kubernetes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../OKD/" title="OKD" class="md-nav__link">
      OKD
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Coreos/" title="ContainerOS" class="md-nav__link">
      ContainerOS
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-13" type="checkbox" id="nav-13">
    
    <label class="md-nav__link" for="nav-13">
      MessageQueue
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-13">
        MessageQueue
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../ActiveMQ/" title="ActiveMQ" class="md-nav__link">
      ActiveMQ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../ActiveMQApollo/" title="ActiveMQ Apollo" class="md-nav__link">
      ActiveMQ Apollo
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Kafka/" title="Kafka" class="md-nav__link">
      Kafka
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../RabbitMQ/" title="RabbitMQ" class="md-nav__link">
      RabbitMQ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-14" type="checkbox" id="nav-14">
    
    <label class="md-nav__link" for="nav-14">
      FileSystem
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-14">
        FileSystem
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Ceph/" title="Ceph" class="md-nav__link">
      Ceph
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../GlusterFS/" title="GlusterFS" class="md-nav__link">
      GlusterFS
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Vsftp/" title="Vsftp" class="md-nav__link">
      Vsftp
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-15" type="checkbox" id="nav-15">
    
    <label class="md-nav__link" for="nav-15">
      Security
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-15">
        Security
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Snort/" title="Snort" class="md-nav__link">
      Snort
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-16" type="checkbox" id="nav-16">
    
    <label class="md-nav__link" for="nav-16">
      Network
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-16">
        Network
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Cisco/" title="Cisco" class="md-nav__link">
      Cisco
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Huawei/" title="Huawei" class="md-nav__link">
      Huawei
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../DNS/" title="DNS" class="md-nav__link">
      DNS
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Mail/" title="Mail" class="md-nav__link">
      Mail
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Samba/" title="Samba" class="md-nav__link">
      Samba
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-17" type="checkbox" id="nav-17">
    
    <label class="md-nav__link" for="nav-17">
      CrossGFW
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-17">
        CrossGFW
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../VPN/" title="VPN" class="md-nav__link">
      VPN
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Shadowsocks/" title="Shadowsocks" class="md-nav__link">
      Shadowsocks
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-18" type="checkbox" id="nav-18">
    
    <label class="md-nav__link" for="nav-18">
      TreasureTheLeisure
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-18">
        TreasureTheLeisure
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../GoogleTricks/" title="GoogleTricks" class="md-nav__link">
      GoogleTricks
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Freeswitch/" title="Freeswitch" class="md-nav__link">
      Freeswitch
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Asterisk/" title="Asterisk" class="md-nav__link">
      Asterisk
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Sipcode/" title="Sipcode" class="md-nav__link">
      Sipcode
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Raspberrypi/" title="Raspberrypi" class="md-nav__link">
      Raspberrypi
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Windows/" title="Windows" class="md-nav__link">
      Windows
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ubuntu-debian" title="Ubuntu--Debian" class="md-nav__link">
    Ubuntu--Debian
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#debian" title="Debian常见命令" class="md-nav__link">
    Debian常见命令
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#centos" title="Centos" class="md-nav__link">
    Centos
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linuxjava" title="Linux安装java" class="md-nav__link">
    Linux安装java
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" title="分区方案参考" class="md-nav__link">
    分区方案参考
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#centospythonyum" title="centos完全重装python和yum" class="md-nav__link">
    centos完全重装python和yum
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ssh" title="更改默认ssh连接端口" class="md-nav__link">
    更改默认ssh连接端口
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" title="优化内核参数 [根据实际情况调整]" class="md-nav__link">
    优化内核参数 [根据实际情况调整]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#root" title="赋予root权限" class="md-nav__link">
    赋予root权限
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" title="服务器配置双机信任" class="md-nav__link">
    服务器配置双机信任
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-float-ip" title="未采用双机热备防止服务中断--float IP" class="md-nav__link">
    未采用双机热备防止服务中断--float IP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#centosip" title="升级centos内核&amp;更改为静态ip、网卡名称" class="md-nav__link">
    升级centos内核&amp;更改为静态ip、网卡名称
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ssh_1" title="SSH相关命令和配置" class="md-nav__link">
    SSH相关命令和配置
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ssh_2" title="SSH协议无密码登陆设定：" class="md-nav__link">
    SSH协议无密码登陆设定：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sshd_configetcsshsshd_config" title="sshd_config配置详解（/etc/ssh/sshd_config）" class="md-nav__link">
    sshd_config配置详解（/etc/ssh/sshd_config）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ssh_3" title="SSH端口转发" class="md-nav__link">
    SSH端口转发
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" title="本地转发实例" class="md-nav__link">
    本地转发实例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" title="远程转发实例" class="md-nav__link">
    远程转发实例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" title="多主机转发应用实例" class="md-nav__link">
    多主机转发应用实例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" title="动态转发实例" class="md-nav__link">
    动态转发实例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#x" title="X协议转发实例" class="md-nav__link">
    X协议转发实例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linux_1" title="linux磁盘详解" class="md-nav__link">
    linux磁盘详解
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#raid0-1-5-10" title="Raid0 1 5 10详解" class="md-nav__link">
    Raid0 1 5 10详解
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#linux_2" title="Linux文件系统目录介绍" class="md-nav__link">
    Linux文件系统目录介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" title="添加硬盘或分区流程" class="md-nav__link">
    添加硬盘或分区流程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_3" title="linux系统引导流程解析" class="md-nav__link">
    linux系统引导流程解析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grub" title="GRUB配置文件讲解：" class="md-nav__link">
    GRUB配置文件讲解：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_4" title="Linux软件包管理" class="md-nav__link">
    Linux软件包管理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_" title="Linux_用户、组和权限" class="md-nav__link">
    Linux_用户、组和权限
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#r-w-x" title="一、权限：r, w, x" class="md-nav__link">
    一、权限：r, w, x
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" title="二、用户和用户组" class="md-nav__link">
    二、用户和用户组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_5" title="Linux用户管理" class="md-nav__link">
    Linux用户管理
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" title="三、管理命令" class="md-nav__link">
    三、管理命令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" title="四、特殊权限" class="md-nav__link">
    四、特殊权限
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_6" title="Linux进程管理" class="md-nav__link">
    Linux进程管理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux5" title="linux上进程有5种状态" class="md-nav__link">
    linux上进程有5种状态
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shell" title="shell脚本笔记" class="md-nav__link">
    shell脚本笔记
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" title="杀死进程命令例子" class="md-nav__link">
    杀死进程命令例子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" title="统计并杀死僵尸进程例子" class="md-nav__link">
    统计并杀死僵尸进程例子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rss" title="进程按rss排序" class="md-nav__link">
    进程按rss排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1pcputid" title="进程按第1列pcpu排序、tid为线程号" class="md-nav__link">
    进程按第1列pcpu排序、tid为线程号
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" title="按进程消耗内存多少排序" class="md-nav__link">
    按进程消耗内存多少排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_7" title="Linux中查看所有正在运行的进程" class="md-nav__link">
    Linux中查看所有正在运行的进程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux-vmware-tools" title="Linux VMware Tools安装步骤简易版" class="md-nav__link">
    Linux VMware Tools安装步骤简易版
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rm" title="恢复rm误删的文件" class="md-nav__link">
    恢复rm误删的文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_8" title="linux常用日志文件默认路径" class="md-nav__link">
    linux常用日志文件默认路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1gswap" title="增加1G的swap空间" class="md-nav__link">
    增加1G的swap空间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_9" title="Linux备份" class="md-nav__link">
    Linux备份
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_10" title="Linux测试硬盘读写速度" class="md-nav__link">
    Linux测试硬盘读写速度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8" title="获取8位随机字符串" class="md-nav__link">
    获取8位随机字符串
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8_1" title="获取8位随机数字" class="md-nav__link">
    获取8位随机数字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" title="定义一个颜色输出字符串函数" class="md-nav__link">
    定义一个颜色输出字符串函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" title="批量创建用户" class="md-nav__link">
    批量创建用户
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bash" title="简单检测某个进程是否存在的bash小脚本。代码如下" class="md-nav__link">
    简单检测某个进程是否存在的bash小脚本。代码如下
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shell_1" title="shell变量的子串的删除/替换" class="md-nav__link">
    shell变量的子串的删除/替换
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" title="清除大于5天的文件" class="md-nav__link">
    清除大于5天的文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shellcpu" title="shell采集系统cpu 内存 磁盘 网络信息" class="md-nav__link">
    shell采集系统cpu 内存 磁盘 网络信息
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cpu" title="cpu信息采集" class="md-nav__link">
    cpu信息采集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" title="内存采集" class="md-nav__link">
    内存采集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" title="磁盘信息采集" class="md-nav__link">
    磁盘信息采集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" title="网络信息采集" class="md-nav__link">
    网络信息采集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shell_2" title="系统管理的常用shell命令" class="md-nav__link">
    系统管理的常用shell命令
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/Black-Gold/MyNotes/edit/master/docs/Linux.md" title="编辑此页" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="linux">Linux<a class="headerlink" href="#linux" title="Permanent link">&para;</a></h1>
<p>系统命令行快捷键</p>
<p>Ctrl+左右键:在单词之间跳转
Ctrl+a:跳到本行的行首
Ctrl+e:跳到页尾
Ctrl+u：删除当前光标前面的文字 （还有剪切功能）
Ctrl+k：删除当前光标后面的文字(还有剪切功能)
Ctrl+L：进行清屏操作
Ctrl+y:粘贴Ctrl+u或ctrl+k剪切的内容
Ctrl+w:删除光标前面的单词的字符
Alt – d ：由光标位置开始，往右删除单词。往行尾删
说明
Ctrl – k: 先按住 Ctrl 键，然后再按 k 键；
Alt – k: 先按住 Alt 键，然后再按 k 键；
M – k：先单击 Esc 键，然后再按 k 键。
移动光标
Ctrl – a ：移到行首
Ctrl – e ：移到行尾
Ctrl – b ：往回(左)移动一个字符
Ctrl – f ：往后(右)移动一个字符
Alt – b ：往回(左)移动一个单词
Alt – f ：往后(右)移动一个单词
Ctrl – xx ：在命令行尾和光标之间移动
M-b ：往回(左)移动一个单词
M-f ：往后(右)移动一个单词
编辑命令
Ctrl – h ：删除光标左方位置的字符
Ctrl – d ：删除光标右方位置的字符（注意：当前命令行没有任何字符时，会注销系统或结束终端）
Ctrl – w ：由光标位置开始，往左删除单词。往行首删
Alt – d ：由光标位置开始，往右删除单词。往行尾删
M – d ：由光标位置开始，删除单词，直到该单词结束。
Ctrl – k ：由光标所在位置开始，删除右方所有的字符，直到该行结束。
Ctrl – u ：由光标所在位置开始，删除左方所有的字符，直到该行开始。
Ctrl – y ：粘贴之前删除的内容到光标后。
ctrl – t ：交换光标处和之前两个字符的位置。
Alt + . ：使用上一条命令的最后一个参数。
Ctrl – _ ：回复之前的状态。撤销操作。
Ctrl -a + Ctrl -k 或 Ctrl -e + Ctrl -u 或 Ctrl -k + Ctrl -u 组合可删除整行。</p>
<p>Bang(!)命令
!! ：执行上一条命令。
<sup>foo</sup>bar ：把上一条命令里的foo替换为bar，并执行。
!wget ：执行最近的以wget开头的命令。
!wget:p ：仅打印最近的以wget开头的命令，不执行。
!$ ：上一条命令的最后一个参数， 与 Alt - . 和 $_ 相同。
!* ：上一条命令的所有参数
!*:p ：打印上一条命令是所有参数，也即 !*的内容。
^abc ：删除上一条命令中的abc。
<sup>foo</sup>bar ：将上一条命令中的 foo 替换为 bar
<sup>foo</sup>bar^ ：将上一条命令中的 foo 替换为 bar
!-n ：执行前n条命令，执行上一条命令： !-1， 执行前5条命令的格式是： !-5
查找历史命令
Ctrl – p ：显示当前命令的上一条历史命令
Ctrl – n ：显示当前命令的下一条历史命令
Ctrl – r ：搜索历史命令，随着输入会显示历史命令中的一条匹配命令，Enter键执行匹配命令；ESC键在命令行显示而不执行匹配命令。
Ctrl – g ：从历史搜索模式（Ctrl – r）退出。
控制命令
Ctrl – l ：清除屏幕，然后，在最上面重新显示目前光标所在的这一行的内容。
Ctrl – o ：执行当前命令，并选择上一条命令。
Ctrl – s ：阻止屏幕输出
Ctrl – q ：允许屏幕输出
Ctrl – c ：终止命令
Ctrl – z ：挂起命令
重复执行操作动作
M – 操作次数 操作动作 ： 指定操作次数，重复执行指定的操作。</p>
<p>lshw -C network</p>
<p>I. stunnel -&gt; vanish -&gt; HAProxy -&gt; nginx -&gt; nodeJS -&gt; memcached(redis) (for session storage[Session 对象存储])</p>
<p>II. nginx (for HTTP compression) –&gt; Varnish cache (for caching) –&gt; HTTP level load balancer (HAProxy, or nginx, or the Varnish built-in) –&gt; webservers.</p>
<p>III. Apache Traffic Server/Squid/Vanish + HAProxy + Nginx + memcached(Redis) (for session storage[Session 对象存储])</p>
<h2 id="ubuntu-debian">Ubuntu--Debian<a class="headerlink" href="#ubuntu-debian" title="Permanent link">&para;</a></h2>
<p><a href="http://kernel.ubuntu.com/~kernel-ppa/mainline/">Ubuntu内核网站</a></p>
<p>系统相关配置</p>
<p>挂起后进入系统输入：xdotool mouseup 1
然后注销重新登录</p>
<p>将Ubuntu启动栏移动到最下方
gsettings set com.canonical.Unity.Launcher launcher-position Bottom</p>
<p>得到启动栏位置
gsettings get com.canonical.Unity.Launcher launcher-position</p>
<p>卸载软件包，清除残余的配置文件
apt-get remove --purge -y
apt-get autoremove --purge -y
sudo apt-get clean
apt-get autoclean
dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P</p>
<p>要删除作为依赖项安装但不再具有父应用程序的软件包，请运行以下命令
apt-get autoremove</p>
<p>删除旧内核
dpkg --purge --force-remove-essential kernel-image-NNN</p>
<p>删除专用软件包
dpkg --get-selections | grep PACKAGE_NAME | awk '{ print $1}'| xargs apt-get -y --purge autoremove</p>
<p>禁用挂起suspend
创建文件：/etc/polkit-1/localauthority/90-mandatory.d/disable-suspend.pkla</p>
<div class="codehilite"><pre><span></span><span class="k">[Disable suspend (upower)]</span>
<span class="na">Identity</span><span class="o">=</span><span class="s">unix-user:*</span>
<span class="na">Action</span><span class="o">=</span><span class="s">org.freedesktop.upower.suspend</span>
<span class="na">ResultActive</span><span class="o">=</span><span class="s">no</span>
<span class="na">ResultInactive</span><span class="o">=</span><span class="s">no</span>
<span class="na">ResultAny</span><span class="o">=</span><span class="s">no</span>

<span class="k">[Disable suspend (logind)]</span>
<span class="na">Identity</span><span class="o">=</span><span class="s">unix-user:*</span>
<span class="na">Action</span><span class="o">=</span><span class="s">org.freedesktop.login1.suspend</span>
<span class="na">ResultActive</span><span class="o">=</span><span class="s">no</span>

<span class="k">[Disable suspend for all sessions (logind)]</span>
<span class="na">Identity</span><span class="o">=</span><span class="s">unix-user:*</span>
<span class="na">Action</span><span class="o">=</span><span class="s">org.freedesktop.login1.suspend-multiple-sessions</span>
<span class="na">ResultActive</span><span class="o">=</span><span class="s">no</span>
</pre></div>

<p>设置临时文件不再放置在硬盘加快速度，而放在虚拟RAM磁盘上。总内存必须大于4G
cp -v /usr/share/systemd/tmp.mount /etc/systemd/system/
systemctl enable tmp.mount
systemctl reload tmp.mount # 不生效可重启计算机。systemctl status tmp.mount检查状态
取消tmpfs,删除后重启生效
rm -v /etc/systemd/system/tmp.mount</p>
<p>减少文件写入(当用于非服务器时)在/etc/fstab写入以下内容：</p>
<div class="codehilite"><pre><span></span>tmpfs    /tmp        tmpfs    defaults    0  0
tmpfs    /var/tmp    tmpfs    defaults    0  0
tmpfs    /var/log    tmpfs    defaults    0  0
</pre></div>

<p>创建脚本确保各种程序正常运行：</p>
<div class="codehilite"><pre><span></span><span class="k">for</span> dir in apparmor apt ConsoleKit cups dist-upgrade fsck gdm installer news ntpstats samba unattended-upgrades <span class="p">;</span> <span class="k">do</span>
<span class="k">if</span> <span class="o">[</span> ! -e /var/log/<span class="nv">$dir</span> <span class="o">]</span> <span class="p">;</span> <span class="k">then</span>
mkdir /var/log/<span class="nv">$dir</span>
<span class="k">fi</span>
<span class="k">done</span>

<span class="c1"># 要确保每次启动计算机时脚本都会运行，您需要将其添加到/etc/rc.local文件中，位于底部，位于exit 0行上方</span>
</pre></div>

<p>系统～/.bashrc和~/.profile文件可通过/etc/skel/目录(系统存储的备份文件)恢复</p>
<p>find: ‘/run/user/1000/gvfs’解决办法</p>
<div class="codehilite"><pre><span></span>sudo umount /run/user/1000/gvfs
sudo rm -rf /run/user/1000/gvfs
</pre></div>

<div class="codehilite"><pre><span></span>pip3 install --no-cache-dir --prefix<span class="o">=</span><span class="s2">&quot;/home/ww/公共的/pip3/&quot;</span> -U -i https://mirrors.huaweicloud.com/repository/pypi/simple some-package-name
</pre></div>

<p>系统调用 尝试“strace -ff -t -s 1000 -p {process id}</p>
<p>sudo apt-get install --only-upgrade packagename</p>
<p>自定义terminal位置和大小
cp /usr/share/applications/gnome-terminal.desktop ~/.local/share/applications
sed -i 's/^Exec=gnome-terminal$/&amp; --geometry=80x24+100+100/' ~/.local/share/applications/gnome-terminal.desktop
gsettings set org.gnome.desktop.default-applications.terminal exec 'gnome-terminal --geometry=80x24+100+100'
删除自定义
rm ~/.local/share/applications/gnome-terminal.desktop
gsettings set org.gnome.desktop.default-applications.terminal exec 'gnome-terminal'</p>
<p>Ubuntu Linux系统环境变量配置文件：
/etc/profile : 在登录时,操作系统定制用户环境时使用的第一个文件 ,此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行。</p>
<p>/etc /environment : 在登录时操作系统使用的第二个文件, 系统在读取你自己的profile前,设置环境文件的环境变量。</p>
<p>~/.profile :  在登录时用到的第三个文件 是.profile文件,每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。</p>
<p>/etc/bashrc : 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</p>
<p>~/.bashrc : 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。</p>
<p>PASH环境变量的设置方法：</p>
<p>方法一：用户主目录下的.profile或.bashrc文件（推荐）</p>
<p>登录到你的用户（非root），在终端输入：
$ sudo gedit ~/.profile(or .bashrc)
可以在此文件末尾加入PATH的设置如下：
export PATH=”$PATH:your path1:your path2 ...”
保存文件，注销再登录，变量生效。
该方式添加的变量只对当前用户有效。</p>
<p>方法二：系统目录下的profile文件（谨慎）</p>
<p>在系统的etc目录下，有一个profile文件，编辑该文件：
$ sudo gedit /etc/profile
在最后加入PATH的设置如下：
export PATH=”$PATH:your path1:your path2 ...”
该文件编辑保存后，重启系统，变量生效。
该方式添加的变量对所有的用户都有效。</p>
<p>方法三：系统目录下的 environment 文件（谨慎）</p>
<p>在系统的etc目录下，有一个environment文件，编辑该文件：
$ sudo gedit /etc/environment
找到以下的 PATH 变量：
PATH="&lt;......&gt;"
修改该 PATH 变量，在其中加入自己的path即可，例如：
PATH="&lt;......&gt;:your path1:your path2 …"
各个path之间用冒号分割。该文件也是重启生效，影响所有用户。
注意这里不是添加export PATH=… 。</p>
<p>方法四：直接在终端下输入</p>
<p>$ sudo export PATH="$PATH:your path1:your path2 …"
这种方式变量立即生效，但用户注销或系统重启后设置变成无效，适合临时变量的设置。</p>
<p>注 意：方法二和三的修改需要谨慎，尤其是通过root用户修改，如果修改错误，将可能导致一些严重的系统错误。因此笔者推荐使用第一种方法。另外嵌入式 Linux的开发最好不要在root下进行（除非你对Linux已经非常熟悉了！！），以免因为操作不当导致系统严重错误。</p>
<p>下面是一个对environment文件错误修改导致的问题以及解决方法示例：</p>
<p>问题：因为不小心在 etc/environment里设在环境变量导致无法登录
提示：不要在 etc/environment里设置 export PATH这样会导致重启后登录不了系统
解决方法：
在登录界面 alt +ctrl+f1进入命令模式，如果不是root用户需要键入（root用户就不许这么罗嗦，gedit编辑会不可显示）
/usr/bin/sudo /usr/bin/vi /etc/environment
光标移到export PATH** 行，连续按 d两次删除该行；
输入:wq保存退出；
然后键入/sbin/reboot重启系统（可能会提示need to boot，此时直接power off）</p>
<h2 id="debian">Debian常见命令<a class="headerlink" href="#debian" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">分类</td>
<td align="center">重要性</td>
<td align="center">命令</td>
<td align="center">描述</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">apropos whatis</td>
<td align="center">显示和word相关的命令。 参见线程安全</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">man -t man</td>
<td align="center">ps2pdf - &gt; man.pdf</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">which command</td>
<td align="center">显示命令的完整路径名</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">time command</td>
<td align="center">计算命令运行的时间</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">time cat</td>
<td align="center">开始计时. Ctrl-d停止。参见sw</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">nice info</td>
<td align="center">运行一个低优先级命令（这里是info）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">renice 19 -p $$</td>
<td align="center">使脚本运行于低优先级。用于非交互任务。</td>
</tr>
<tr>
<td align="center">目录操作</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">cd -</td>
<td align="center">回到前一目录</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">cd</td>
<td align="center">回到用户目录</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">cd dir &amp;&amp; command</td>
<td align="center">进入目录dir，执行命令command然后回到当前目录</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">pushd .</td>
<td align="center">将当前目录压入栈，以后你可以使用popd回到此目录</td>
</tr>
<tr>
<td align="center">文件搜索</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">alias l='ls -l --color=auto'</td>
<td align="center">单字符文件列表命令</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">ls -lrt</td>
<td align="center">按日期显示文件. 参见newest</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">ls /usr/bin</td>
<td align="center">pr -T9 -W$COLUMNS</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">find -name '*.[ch]'</td>
<td align="center">xargs grep -E 'expr'</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">find -type f -print0</td>
<td align="center">xargs -r0 grep -F 'example'</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">find -maxdepth 1 -type f</td>
<td align="center">xargs grep -F 'example'</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">find -maxdepth 1 -type d</td>
<td align="center">while read dir; do echo $dir; echo cmd2; done</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">find -type f ! -perm -444</td>
<td align="center">寻找所有不可读的文件对网站有用</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">find -type d ! -perm -111</td>
<td align="center">寻找不可访问的目录对网站有用</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">locate -r 'file[^/]*.txt'</td>
<td align="center">使用locate 查找所有符合*file*.txt的文件</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">look reference</td>
<td align="center">在（有序）字典中快速查找</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">grep --color reference /usr/share/dict/words</td>
<td align="center">使字典中匹配的正则表达式高亮</td>
</tr>
<tr>
<td align="center">归档 and compression</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">gpg -c file</td>
<td align="center">文件加密</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">gpg file.gpg</td>
<td align="center">文件解密</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">tar -c dir/</td>
<td align="center">bzip2 &gt; dir.tar.bz2</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">bzip2 -dc dir.tar.bz2</td>
<td align="center">tar -x</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">tar -c dir/</td>
<td align="center">gzip</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">find dir/ -name '*.txt'</td>
<td align="center">tar -c --files-from=-</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">find dir/ -name '*.txt'</td>
<td align="center">xargs cp -a --target-directory=dir_txt/ --parents</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">tar -c /dir/to/copy</td>
<td align="center">cd /where/to/ &amp;&amp; tar -x -p</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">cd /dir/to/copy &amp;&amp; tar -c .</td>
<td align="center">cd /where/to/ &amp;&amp; tar -x -p</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">tar -c /dir/to/copy</td>
<td align="center">ssh -C user@remote 'cd /where/to/ &amp;&amp; tar -x -p'</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">dd bs=1M if=/dev/sda</td>
<td align="center">gzip</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">rsync 使用 --dry-run选项进行测试</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">rsync -P rsync://rsync.server.com/path/to/file file</td>
<td align="center">只获取diffs.当下载有问题时可以作多次</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">rsync --bwlimit=1000 fromfile tofile</td>
<td align="center">有速度限制的本地拷贝，对I/O有利</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">rsync -az -e ssh --delete ~/public_html/ remote.com:'~/public_html'</td>
<td align="center">镜像网站使用压缩和加密</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">rsync -auz -e ssh remote:/dir/ . &amp;&amp; rsync -auz -e ssh . remote:/dir/</td>
<td align="center">同步当前目录和远程目录</td>
</tr>
<tr>
<td align="center">ssh 安全 Shell</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">ssh <span><span class="MathJax_Preview">USER@</span><script type="math/tex">USER@</script></span>HOST command</td>
<td align="center">在<span><span class="MathJax_Preview">Host主机上以</span><script type="math/tex">Host主机上以</script></span>User用户运行命令默认命令为Shell</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">ssh -f -Y <span><span class="MathJax_Preview">USER@</span><script type="math/tex">USER@</script></span>HOSTNAME xeyes</td>
<td align="center">在名为<span><span class="MathJax_Preview">HOSTNAME的主机上以</span><script type="math/tex">HOSTNAME的主机上以</script></span>USER用户运行GUI命令</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">scp -p -r <span><span class="MathJax_Preview">USER@</span><script type="math/tex">USER@</script></span>HOST: file dir/</td>
<td align="center">拷贝到<span><span class="MathJax_Preview">HOST主机</span><script type="math/tex">HOST主机</script></span>USER'用户的目录下</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">ssh -g -L 8080:localhost:80 root@$HOST</td>
<td align="center">由本地主机的8080端口转发到$HOST主机的80端口</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">ssh -R 1434:imap:143 root@$HOST</td>
<td align="center">由主机的1434端口转发到imap的143端口</td>
</tr>
<tr>
<td align="center">wget 多用途下载工具</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">cd cmdline &amp;&amp; wget -nd -pHEKk <a href="http://www.pixelbeat.org/cmdline.html">http://www.pixelbeat.org/cmdline.html</a></td>
<td align="center">在当前目录中下载指定网页及其相关的文件使其可完全浏览</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">wget -c &lt;<a href="http://www.example.com/large.file">http://www.example.com/large.file</a></td>
<td align="center">继续上次未完的下载</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">wget -r -nd -np -l1 -A '*.jpg' <a href="http://www.example.com/">http://www.example.com/</a></td>
<td align="center">批量下载文件到当前目录中</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">wget ftp://remote/file[1-9].iso/</td>
<td align="center">下载FTP站上的整个目录</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">wget -q -O- <a href="http://www.pixelbeat.org/timeline.html">http://www.pixelbeat.org/timeline.html</a></td>
<td align="center">grep 'a href'</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">echo 'wget url'</td>
<td align="center">at 01:00</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">wget --limit-rate=20k url</td>
<td align="center">限制下载速度这里限制到20KB/s</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">wget -nv --spider --force-html -i bookmarks.html</td>
<td align="center">检查文件中的链接是否存在</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">wget --mirror <a href="http://www.example.com/">http://www.example.com/</a></td>
<td align="center">更新网站的本地拷贝可以方便地用于cron</td>
</tr>
<tr>
<td align="center">网络ifconfig, route, mii-tool, nslookup 命令皆已过时</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">ethtool eth0</td>
<td align="center">显示网卡eth0的状态</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">ethtool --change eth0 autoneg off speed 100 duplex full</td>
<td align="center">手动设制网卡速度</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">iwconfig eth1</td>
<td align="center">显示无线网卡eth1的状态</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">iwconfig eth1 rate 1Mb/s fixed</td>
<td align="center">手动设制无线网卡速度</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">iwlist scan</td>
<td align="center">显示无线网络列表</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">ip link show</td>
<td align="center">显示interface列表</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">ip link set dev eth0 name wan</td>
<td align="center">重命名eth0为wan</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">ip link set dev eth0 up</td>
<td align="center">启动interface eth0或关闭</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">ip addr show</td>
<td align="center">显示网卡的IP地址</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">ip addr add 1.2.3.4/24 brd + dev eth0</td>
<td align="center">添加ip和掩码255.255.255.0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">ip route show</td>
<td align="center">显示路由列表</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">ip route add default via 1.2.3.254</td>
<td align="center">设置默认网关1.2.3.254</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">tc qdisc add dev lo root handle 1:0 netem delay 20msec</td>
<td align="center">增加20ms传输时间到loopback设备调试用</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">tc qdisc del dev lo root</td>
<td align="center">移除上面添加的传输时间</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">host pixelbeat.org</td>
<td align="center">查寻主机的DNS IP地址</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">hostname -i</td>
<td align="center">查寻本地主机的IP地址同等于host <code class="codehilite">hostname</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">whois pixelbeat.org</td>
<td align="center">查寻某主机或莫IP地址的whois信息</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">netstat -tupl</td>
<td align="center">列出系统中的internet服务</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">netstat -tup</td>
<td align="center">列出活跃的连接</td>
</tr>
<tr>
<td align="center">windows networking samba提供所有windows相关的网络支持</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">smbtree</td>
<td align="center">寻找一个windows主机. 参见findsmb</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">nmblookup -A 1.2.3.4</td>
<td align="center">寻找一个指定ip的windows netbios名</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">smbclient -L windows_box</td>
<td align="center">显示在windows主机或samba服务器上的所有共享</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">mount -t smbfs -o fmask=666,guest //windows_box/share /mnt/share</td>
<td align="center">挂载一个windows共享</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">echo 'message'</td>
<td align="center">smbclient -M windows_box</td>
</tr>
<tr>
<td align="center">文本操作 sed使用标准输入和标准输出，如果想要编辑文件，则需添加\<oldfile>newfile</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">sed 's/string1/string2/g'</td>
<td align="center">使用string2替换string1</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">sed 's/.*\1/\12/g'</td>
<td align="center">将任何以1结尾的字符串替换为以2结尾的字符串</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">sed '/^ *#/d; /^ *$/d'</td>
<td align="center">删除注释和空白行</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">sed ':a; /\$/N; s/\\n//; ta'</td>
<td align="center">连接结尾有\的行和其下一行</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">sed 's/[ \t]*$//'</td>
<td align="center">删除每行后的空白</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">sed 's/[\`\"$\\]\/\\1/g'</td>
<td align="center">将所有转义字符之前加上\</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">seq 10</td>
<td align="center">sed "s/^/      /; s/ *.{7,}\/\1/"</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">sed -n '1000p;1000q'</td>
<td align="center">输出第一千行</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">sed -n '10,20p;20q'</td>
<td align="center">输出第10-20行</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">sed -n 's/.<em><title\>\.*\<\/title>.</em>/\1/ip;T;q'</td>
<td align="center">输出HTML文件的<title></title>字段中的 内容</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">sort -t. -k1,1n -k2,2n -k3,3n -k4,4n</td>
<td align="center">排序IPV4地址</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">echo 'Test'</td>
<td align="center">tr '[:lower:]' '[:upper:]'</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">tr -dc '[:print:]' &lt; /dev/urandom</td>
<td align="center">过滤掉不能打印的字符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">history</td>
<td align="center">wc -l</td>
</tr>
<tr>
<td align="center">集合操作 如果是英文文本的话export LANG=C可以提高速度</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">sort -u file1 file2</td>
<td align="center">两个未排序文件的并集</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">sort file1 file2</td>
<td align="center">uniq -d</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">sort file1 file1 file2</td>
<td align="center">uniq -u</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">sort file1 file2</td>
<td align="center">uniq -u</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">join -t'\0' -a1 -a2 file1 file2</td>
<td align="center">两个有序文件的并集</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">join -t'\0' file1 file2</td>
<td align="center">两个有序文件的交集</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">join -t'\0' -v2 file1 file2</td>
<td align="center">两个有序文件的差集</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">join -t'\0' -v1 -v2 file1 file2</td>
<td align="center">两个有序文件的对称差集</td>
</tr>
<tr>
<td align="center">数学</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">echo '1 + sqrt5/2'</td>
<td align="center">bc -l</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">echo 'pad=20; min=64; 100*10^6/pad+min*8'</td>
<td align="center">bc</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">echo 'pad=20; min=64; print 100E6/pad+min*8'</td>
<td align="center">python</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">echo 'pad=20; plot [64:1518] 100*10**6/pad+x*8'</td>
<td align="center">gnuplot -persist</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">echo 'obase=16; ibase=10; 64206'</td>
<td align="center">bc</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">echo $0x2dec</td>
<td align="center">进制转换十六进制到十进制shell数学扩展</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">units -t '100m/9.58s' 'miles/hour'</td>
<td align="center">单位转换公尺到英尺</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">units -t '500GB' 'GiB'</td>
<td align="center">单位转换SI 到IEC 前缀. 参见 numfmt</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">units -t '1 googol'</td>
<td align="center">定义查找</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">seq 100</td>
<td align="center">tr '\n' +; echo 0</td>
</tr>
<tr>
<td align="center">日历</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">cal -3</td>
<td align="center">显示一日历</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">cal 9 1752</td>
<td align="center">显示指定月，年的日历</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">date -d fri</td>
<td align="center">这个星期五是几号. 参见day</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">date --date='25 Dec' +%A</td>
<td align="center">今年的圣诞节是星期几</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">date --date '1970-01-01 UTC 2147483647 seconds'</td>
<td align="center">将一相对于1970-01-01 00：00的秒数转换成时间</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">TZ=':America/Los_Angeles' date</td>
<td align="center">显示当前的美国西岸时间使用tzselect寻找时区</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">echo "mail -s 'get the train' <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#80;&#64;&#100;&#114;&#97;&#105;&#103;&#66;&#114;&#97;&#100;&#121;&#46;&#99;&#111;&#109;">&#80;&#64;&#100;&#114;&#97;&#105;&#103;&#66;&#114;&#97;&#100;&#121;&#46;&#99;&#111;&#109;</a> &lt; /dev/null"</td>
<td align="center">at 17:45</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">echo "DISPLAY=$DISPLAY xmessage cooker"</td>
<td align="center">at "NOW + 30 minutes"</td>
</tr>
<tr>
<td align="center">locales</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">printf "%'d\n" 1234</td>
<td align="center">根据locale输出正确的数字分隔</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">BLOCK_SIZE=\'1 ls -l</td>
<td align="center">用ls命令作类适于locale文件分组</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">echo "I live in <code class="codehilite">locale territory</code>"</td>
<td align="center">从locale数据库中展开信息</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">LANG=en_IE.utf8 locale int_prefix</td>
<td align="center">查找指定地区的locale信息。参见ccodes</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">locale</td>
<td align="center">cut -d= -f1</td>
</tr>
<tr>
<td align="center">recode iconv, dos2unix, unix2dos 已经过时了</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">recode -l</td>
<td align="center">less</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">recode windows-1252.. file_to_change.txt</td>
<td align="center">转换Windows下的ansi文件到当前的字符集自动进行回车换行符的转换</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">recode utf-8/CRLF.. file_to_change.txt</td>
<td align="center">转换Windows下的ansi文件到当前的字符集</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">recode iso-8859-15..utf8 file_to_change.txt</td>
<td align="center">转换Latin9（西欧）字符集文件到utf8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">recode ../b64 &lt; file.txt &gt; file.b64</td>
<td align="center">Base64编码</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">recode /qp.. &lt; file.txt &gt; file.qp</td>
<td align="center">Quoted-printable格式解码</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">recode ..HTML &lt; file.txt &gt; file.html</td>
<td align="center">将文本文件转换成HTML</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">recode -lf windows-1252</td>
<td align="center">grep euro</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">echo -n 0x80</td>
<td align="center">recode latin-9/x1..dump</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">echo -n 0x20AC</td>
<td align="center">recode ucs-2/x2..latin-9/x</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">echo -n 0x20AC</td>
<td align="center">recode ucs-2/x2..utf-8/x</td>
</tr>
<tr>
<td align="center">光盘</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">gzip &lt; /dev/cdrom &gt; cdrom.iso.gz</td>
<td align="center">保存光盘拷贝</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">mkisofs -V LABEL -r dir</td>
<td align="center">gzip &gt; cdrom.iso.gz</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">mount -o loop cdrom.iso /mnt/dir</td>
<td align="center">将光盘镜像挂载到 /mnt/dir 只读</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">cdrecord -v dev=/dev/cdrom blank=fast</td>
<td align="center">清空一张CDRW</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">gzip -dc cdrom.iso.gz</td>
<td align="center">cdrecord -v dev=/dev/cdrom -</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">cdparanoia -B</td>
<td align="center">在当前目录下将光盘音轨转录成wav文件</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">cdrecord -v dev=/dev/cdrom -audio *.wav</td>
<td align="center">将当前目录下的wav文件烧成音乐光盘 参见cdrdao</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">oggenc --tracknum='track' track.cdda.wav -o 'track.ogg'</td>
<td align="center">将wav文件转换成ogg格式</td>
</tr>
<tr>
<td align="center">磁盘空间 参见FSlint</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">ls -lSr</td>
<td align="center">按文件大小降序显示文件</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">du -s *</td>
<td align="center">sort -k1,1rn</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">df -h</td>
<td align="center">显示空余的磁盘空间</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">df -i</td>
<td align="center">显示空余的inode</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">fdisk -l</td>
<td align="center">显示磁盘分区大小和类型（在root下执行）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">rpm -q -a --qf '%10{SIZE}\t%{NAME}\n'</td>
<td align="center">sort -k1,1n</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">dpkg-query -W -f='<span><span class="MathJax_Preview">{Installed-Size;10}\t</span><script type="math/tex">{Installed-Size;10}\t</script></span>{Package}\n'</td>
<td align="center">sort -k1,1n</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">dd bs=1 seek=2TB if=/dev/null of=ext3.test</td>
<td align="center">建立一个大的测试文件（不占用空间）. 参见truncate</td>
</tr>
<tr>
<td align="center">监视/调试</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">tail -f /var/log/messages</td>
<td align="center">监视Messages日志文件</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">strace -c ls &gt;/dev/null</td>
<td align="center">总结/剖析命令进行的系统调用</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">strace -f -e open ls &gt;/dev/null</td>
<td align="center">显示命令进行的系统调用</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">ltrace -f -e getenv ls &gt;/dev/null</td>
<td align="center">显示命令调用的库函数</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">lsof -p $$</td>
<td align="center">显示当前进程打开的文件</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">lsof ~</td>
<td align="center">显示打开用户目录的进程</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">tcpdump not port 22</td>
<td align="center">显示除了ssh外的网络交通. 参见tcpdump_not_me</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">ps -e -o pid,args --forest</td>
<td align="center">以树状结构显示进程</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">ps -e -o pcpu,cpu,nice,state,cputime,args --sort pcpu</td>
<td align="center">sed '/^ 0.0 /d'</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">ps -e -orss=,args=</td>
<td align="center">sort -b -k1,1n</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">ps -C firefox-bin -L -o pid,tid,pcpu,state</td>
<td align="center">显示指定进程的所有线程信息</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">ps -p 1,2</td>
<td align="center">显示指定进程ID的进程信息</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">last reboot</td>
<td align="center">显示系统重启记录</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">free -m</td>
<td align="center">显示剩余的内存总量-m以MB为单位显示</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">watch -n.1 'cat /proc/interrupts'</td>
<td align="center">监测文件/proc/interrupts的变化</td>
</tr>
<tr>
<td align="center">系统信息 参见sysinfo</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">uname -a</td>
<td align="center">查看内核/操作系统/CPU信息</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">head -n1 /etc/issue</td>
<td align="center">查看操作系统版本</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">cat /proc/partitions</td>
<td align="center">显示所有在系统中注册的分区</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">grep MemTotal /proc/meminfo</td>
<td align="center">显示系统可见的内存总量</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">grep "model name" /proc/cpuinfo</td>
<td align="center">显示CPU信息</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">lspci -tv</td>
<td align="center">显示PCI信息</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">lsusb -tv</td>
<td align="center">显示USB信息</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">mount</td>
<td align="center">column -t</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">#</td>
<td align="center">dmidecode -q</td>
<td align="center">less</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">#</td>
<td align="center">smartctl -A /dev/sda</td>
<td align="center">grep Power_On_Hours</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">#</td>
<td align="center">hdparm -i /dev/sda</td>
<td align="center">显示关于磁盘sda的信息</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">#</td>
<td align="center">hdparm -tT /dev/sda</td>
<td align="center">检测磁盘sda的读取速度</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">#</td>
<td align="center">badblocks -s /dev/sda</td>
<td align="center">检测磁盘sda上所有的坏扇区</td>
</tr>
<tr>
<td align="center">交互 参见linux keyboard shortcut database</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">readline</td>
<td align="center">Line editor used by bash, python, bc, gnuplot, ...</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">screen</td>
<td align="center">多窗口的虚拟终端, ...</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">mc</td>
<td align="center">强大的文件管理器，可以浏览rpm, tar, ftp, ssh, ...</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">gnuplot</td>
<td align="center">交互式并可进行脚本编程的画图工具</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">links</td>
<td align="center">网页浏览器</td>
</tr>
<tr>
<td align="center">miscellaneous</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">alias hd='od -Ax -tx1z -v'</td>
<td align="center">方便的十六进制输出。 用法举例: • hd /proc/self/cmdline</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">alias realpath='readlink -f'</td>
<td align="center">显示符号链接指向的真实路径用法举例: • realpath ~/../$USER</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">set</td>
<td align="center">grep $USER</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">touch -c -t 0304050607 file</td>
<td align="center">改变文件的时间标签 YYMMDDhhmm</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">•</td>
<td align="center">python -m SimpleHTTPServer</td>
<td align="center">Serve current directory tree at http://$HOSTNAME:8000/</td>
</tr>
</tbody>
</table>
<h2 id="centos">Centos<a class="headerlink" href="#centos" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span> 更改yum源为阿里云

1、备份
    mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
2、下载新的CentOS-Base.repo 到/etc/yum.repos.d/
    CentOS 5
    wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo
    curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo
    CentOS 6
    wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo
    curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo
    CentOS 7
    wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
    curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo

更改yum源为163

 首先备份/etc/yum.repos.d/CentOS-Base.repo
 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
 下载对应版本repo文件, 放入/etc/yum.repos.d/(操作前请做好相应备份)
 CentOS7 http://mirrors.163.com/.help/CentOS7-Base-163.repo
 CentOS6 http://mirrors.163.com/.help/CentOS6-Base-163.repo
 CentOS5 http://mirrors.163.com/.help/CentOS5-Base-163.repo
 运行以下命令生成缓存
 yum clean all
 yum makecache fast
3、之后运行yum makecache生成缓存
    yum -y upgrade  #只升级所有包，不升级软件和系统内核
    yum -y update   #升级所有包同时也升级软件和系统内核
在线安装epel源
    rpm -ivh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
    To enable the EPEL repositories in CentOS/RHEL 7.x enter following command:
    yum -y install epel-release
</pre></div>

<h2 id="linuxjava">Linux安装java<a class="headerlink" href="#linuxjava" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span>在CentOS7安装Oracle Java JDK8
     rpm -qa <span class="p">|</span> grep -E <span class="s1">&#39;^open[jre|jdk]|j[re|dk]&#39;</span>    <span class="c1"># 查找已安装的jdk组件</span>
     yum remove java-<span class="nv">$Version</span>   <span class="c1"># 卸载之前已安装的jdk</span>
    在/usr目录创建java文件夹，下载jdk包http://www.oracle.com/technetwork/java/javase/downloads/index.html
     mkdir /usr/java
     wget http://download.oracle.com/otn-pub/java/jdk/8u161-b12/...tar.gz
     tar -zxvf jdk...
    编辑.bashrc文件，在export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL下面添加如下代码：
     <span class="nb">export</span> <span class="nv">JAVA_HOME</span><span class="o">=</span>/usr/java/jdk-<span class="nv">$version</span>
     <span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$JAVA_HOME</span>/bin:<span class="nv">$PATH</span>
     <span class="nb">export</span> <span class="nv">CLASSPATH</span><span class="o">=</span>.:<span class="nv">$JAVA_HOME</span>/lib/dt.jar:<span class="nv">$JAVA_HOME</span>/lib/tools.jar
    配置生效并验证
     <span class="nb">source</span> .bashrc
     java --version
</pre></div>

<h2 id="_1">分区方案参考<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span>http://blog.51cto.com/oldboy/634725
</pre></div>

<h2 id="centospythonyum">centos完全重装python和yum<a class="headerlink" href="#centospythonyum" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><span class="mi">1</span><span class="err">、删除现有</span><span class="n">Python</span>
<span class="n">rpm</span> <span class="o">-</span><span class="n">qa</span><span class="o">|</span><span class="n">grep</span> <span class="n">python</span><span class="o">|</span> <span class="n">xargs</span> <span class="n">rpm</span> <span class="o">-</span><span class="n">ev</span> <span class="o">--</span><span class="n">allmatches</span> <span class="o">--</span><span class="n">nodeps</span> <span class="c1">##强制删除已安装程序及其关联</span>
<span class="n">whereis</span> <span class="n">python</span> <span class="o">|</span> <span class="n">xargs</span> <span class="n">rm</span> <span class="o">-</span><span class="n">frv</span> <span class="c1">##删除所有残余文件 ##xargs，允许你对输出执行其他某些命令</span>
<span class="n">whereis</span> <span class="n">python</span> <span class="c1">##验证删除，返回无结果</span>
<span class="mi">2</span><span class="err">、删除现有的</span><span class="n">yum</span>
<span class="n">rpm</span> <span class="o">-</span><span class="n">qa</span><span class="o">|</span><span class="n">grep</span> <span class="n">yum</span><span class="o">|</span> <span class="n">xargs</span> <span class="n">rpm</span> <span class="o">-</span><span class="n">ev</span> <span class="o">--</span><span class="n">allmatches</span> <span class="o">--</span><span class="n">nodeps</span>
<span class="n">whereis</span> <span class="n">yum</span> <span class="o">|</span> <span class="n">xargs</span> <span class="n">rm</span> <span class="o">-</span><span class="n">frv</span>
<span class="mi">3</span><span class="err">、从</span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">mirrors</span><span class="o">.</span><span class="n">aliyun</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">centos</span><span class="o">/</span><span class="mi">7</span><span class="o">/</span><span class="n">os</span><span class="o">/</span><span class="n">x86_64</span><span class="o">/</span><span class="n">Packages</span><span class="o">/</span><span class="err">下载相应的包</span>
<span class="err">由于源中版本会更新，具体请查看</span><span class="n">URL中的版本再下载下来</span><span class="err">！</span>
<span class="n">rpm</span> <span class="o">-</span><span class="n">Uvh</span> <span class="o">--</span><span class="n">replacepkgs</span> <span class="o">*.</span><span class="n">rpm</span>
<span class="err">可能之间还需要</span><span class="n">zlib和zlib</span><span class="o">-</span><span class="n">devel包</span><span class="err">，根据情况下载并安装！</span>
<span class="mi">3</span><span class="err">、运行</span><span class="n">python进行测试</span>
<span class="p">[</span><span class="n">root</span><span class="nd">@localhost</span> <span class="o">~</span><span class="p">]</span><span class="c1"># python</span>
<span class="n">Python</span> <span class="mf">2.7</span><span class="o">.</span><span class="mi">5</span> <span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">Aug</span>  <span class="mi">4</span> <span class="mi">2017</span><span class="p">,</span> <span class="mo">00</span><span class="p">:</span><span class="mi">39</span><span class="p">:</span><span class="mi">18</span><span class="p">)</span>
<span class="p">[</span><span class="n">GCC</span> <span class="mf">4.8</span><span class="o">.</span><span class="mi">5</span> <span class="mi">20150623</span> <span class="p">(</span><span class="n">Red</span> <span class="n">Hat</span> <span class="mf">4.8</span><span class="o">.</span><span class="mi">5</span><span class="o">-</span><span class="mi">16</span><span class="p">)]</span> <span class="n">on</span> <span class="n">linux2</span>
<span class="n">Type</span> <span class="s2">&quot;help&quot;</span><span class="p">,</span> <span class="s2">&quot;copyright&quot;</span><span class="p">,</span> <span class="s2">&quot;credits&quot;</span> <span class="ow">or</span> <span class="s2">&quot;license&quot;</span> <span class="k">for</span> <span class="n">more</span> <span class="n">information</span><span class="o">.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">yum</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="err">如上，要是什么都没报，则说明</span><span class="n">OK啦</span><span class="o">~</span>
<span class="err">源码编译安装</span><span class="n">yum</span>
<span class="n">wget</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">yum</span><span class="o">.</span><span class="n">baseurl</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">download</span><span class="o">/</span><span class="mf">3.4</span><span class="o">/</span><span class="n">yum</span><span class="o">-</span><span class="mf">3.4</span><span class="o">.</span><span class="mf">3.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span>
<span class="n">tar</span> <span class="n">xvf</span> <span class="n">yum</span><span class="o">-</span><span class="mf">3.4</span><span class="o">.</span><span class="mf">3.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span>
<span class="n">cd</span> <span class="n">yum</span><span class="o">-</span><span class="mf">3.4</span><span class="o">.</span><span class="mi">3</span>
<span class="n">yummain</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span> <span class="n">yum</span>
<span class="err">结果提示错误：</span> <span class="n">CRITICAL</span><span class="p">:</span><span class="n">yum</span><span class="o">.</span><span class="n">cli</span><span class="p">:</span><span class="n">Config</span> <span class="n">Error</span><span class="p">:</span> <span class="n">Error</span> <span class="n">accessing</span> <span class="nb">file</span> <span class="k">for</span> <span class="n">config</span> <span class="nb">file</span><span class="p">:</span><span class="o">///</span><span class="n">etc</span><span class="o">/</span>
<span class="err">缺少配置文件。在</span><span class="n">etc目录下面新建yum</span><span class="o">.</span><span class="n">conf文件</span><span class="err">，然后再次运行</span> <span class="n">yummain</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span> <span class="n">yum</span><span class="err">，顺利完成安装。</span>
</pre></div>

<h3 id="ssh">更改默认ssh连接端口<a class="headerlink" href="#ssh" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="m">1</span>、防火墙开放端口

在这里我们是要将默认的ssh端口22修改为2121，所以要将2121端口在防火墙打开

/sbin/iptables -I INPUT -p tcp --dport <span class="m">2121</span> -j ACCEPT

/etc/rc.d/init.d/iptables save

sed -i <span class="s2">&quot;/A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT/d&quot;</span> /etc/sysconfig/iptables

service iptables restart

<span class="m">2</span>、修改sshd_config文件，将#Port 22直接替换成Port <span class="m">2121</span>

sed -i <span class="s1">&#39;s/#Port 22/Port 2121/&#39;</span> /etc/ssh/sshd_config

<span class="m">3</span>、重启SSH服务

service sshd restart

这个时候就无法使用22端口进行ssh远程连接，必须使用2121端口
</pre></div>

<h2 id="_2">优化内核参数 [根据实际情况调整]<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<p>两种修改内核参数方法:
1、使用echo value方式直接追加到文件里如echo "1" &gt;/proc/sys/net/ipv4/tcp_syn_retries，但这种方法设备重启后又会恢复为默认值</p>
<p>2、把参数添加到/etc/sysctl.conf中，然后执行sysctl -p使参数生效，永久生效</p>
<p>内核生产环境常用优化参数参考，具体优化值要参考应用场景</p>
<div class="codehilite"><pre><span></span>net.ipv4.tcp_syn_retries <span class="o">=</span> <span class="m">1</span>

net.ipv4.tcp_synack_retries <span class="o">=</span> <span class="m">1</span>

net.ipv4.tcp_keepalive_time <span class="o">=</span> <span class="m">600</span>

net.ipv4.tcp_keepalive_probes <span class="o">=</span> <span class="m">3</span>

net.ipv4.tcp_keepalive_intvl <span class="o">=</span><span class="m">15</span>

net.ipv4.tcp_retries2 <span class="o">=</span> <span class="m">5</span>

<span class="c1"># 增加tcp-time-wait存储桶大小以防止简单的DOS攻击</span>
net.ipv4.tcp_max_tw_buckets <span class="o">=</span> <span class="m">36000</span>
net.ipv4.tcp_tw_recycle <span class="o">=</span> <span class="m">1</span> <span class="c1"># 默认为0</span>
net.ipv4.tcp_tw_reuse <span class="o">=</span> <span class="m">1</span> <span class="c1"># 默认为0</span>

net.ipv4.tcp_max_orphans <span class="o">=</span> <span class="m">32768</span>

net.ipv4.tcp_syncookies <span class="o">=</span> <span class="m">1</span>

net.ipv4.tcp_max_syn_backlog <span class="o">=</span> <span class="m">16384</span>

net.ipv4.tcp_wmem <span class="o">=</span> <span class="m">8192</span> <span class="m">131072</span> <span class="m">16777216</span>
net.ipv4.udp_wmem_min <span class="o">=</span> <span class="m">16384</span>   <span class="c1"># 增加可分配的写缓冲区空间</span>

net.ipv4.tcp_rmem <span class="o">=</span> <span class="m">32768</span> <span class="m">131072</span> <span class="m">16777216</span>

net.ipv4.tcp_mem <span class="o">=</span> <span class="m">786432</span> <span class="m">1048576</span> <span class="m">1572864</span>

net.ipv4.ip_local_port_range <span class="o">=</span> <span class="m">1024</span> <span class="m">65000</span>

net.ipv4.ip_conntrack_max <span class="o">=</span> <span class="m">65536</span>
-
net.ipv4.netfilter.ip_conntrack_max<span class="o">=</span><span class="m">65536</span>

net.ipv4.netfilter.ip_conntrack_tcp_timeout_established<span class="o">=</span><span class="m">180</span>

net.core.somaxconn <span class="o">=</span> <span class="m">16384</span>

net.core.netdev_max_backlog <span class="o">=</span> <span class="m">16384</span>
net.core.optmem_max <span class="o">=</span> <span class="m">25165824</span>  <span class="c1"># 增加内存缓冲区的最大数量</span>
net.core.busy_poll <span class="o">=</span> <span class="m">50</span> <span class="c1"># 轮询有助于减少网络接收路径中的延迟 允许套接字层代码轮询网络设备的接收队列， 并禁用网络中断。</span>
</pre></div>

<div class="codehilite"><pre><span></span><span class="c1">#优化TCP</span>
vi /etc/sysctl.conf
<span class="c1">#禁用包过滤功能</span>
net.ipv4.ip_forward <span class="o">=</span> <span class="m">0</span>
<span class="c1">#启用源路由核查功能</span>
net.ipv4.conf.default.rp_filter <span class="o">=</span> <span class="m">1</span>
<span class="c1">#禁用所有IP源路由</span>
net.ipv4.conf.default.accept_source_route <span class="o">=</span> <span class="m">0</span>
<span class="c1">#使用sysrq组合键是了解系统目前运行情况，为安全起见设为0关闭</span>
kernel.sysrq <span class="o">=</span> <span class="m">0</span>
<span class="c1">#控制core文件的文件名是否添加pid作为扩展</span>
kernel.core_uses_pid <span class="o">=</span> <span class="m">1</span>
<span class="c1">#开启SYN Cookies，当出现SYN等待队列溢出时，启用cookies来处理</span>
net.ipv4.tcp_syncookies <span class="o">=</span> <span class="m">1</span>
<span class="c1">#每个消息队列的大小（单位：字节）限制</span>
kernel.msgmnb <span class="o">=</span> <span class="m">65536</span>
<span class="c1">#整个系统最大消息队列数量限制</span>
kernel.msgmax <span class="o">=</span> <span class="m">65536</span>
<span class="c1">#单个共享内存段的大小（单位：字节）限制，计算公式64G*1024*1024*1024(字节)</span>
kernel.shmmax <span class="o">=</span> <span class="m">68719476736</span>
<span class="c1">#所有内存大小（单位：页，1页 = 4Kb），计算公式16G*1024*1024*1024/4KB(页)</span>
kernel.shmall <span class="o">=</span> <span class="m">4294967296</span>
<span class="c1">#timewait的数量，默认是180000</span>
net.ipv4.tcp_max_tw_buckets <span class="o">=</span> <span class="m">6000</span>
<span class="c1">#开启有选择的应答</span>
net.ipv4.tcp_sack <span class="o">=</span> <span class="m">1</span>
<span class="c1">#支持更大的TCP窗口. 如果TCP窗口最大超过65535(64K), 必须设置该数值为1</span>
net.ipv4.tcp_window_scaling <span class="o">=</span> <span class="m">1</span>
<span class="c1">#TCP读buffer</span>
net.ipv4.tcp_rmem <span class="o">=</span> <span class="m">4096</span> <span class="m">131072</span> <span class="m">1048576</span>
<span class="c1">#TCP写buffer</span>
net.ipv4.tcp_wmem <span class="o">=</span> <span class="m">4096</span> <span class="m">131072</span> <span class="m">1048576</span>
<span class="c1">#为TCP socket预留用于发送缓冲的内存默认值（单位：字节）</span>
net.core.wmem_default <span class="o">=</span> <span class="m">8388608</span>
<span class="c1">#为TCP socket预留用于发送缓冲的内存最大值（单位：字节）</span>
net.core.wmem_max <span class="o">=</span> <span class="m">16777216</span>
<span class="c1">#为TCP socket预留用于接收缓冲的内存默认值（单位：字节）</span>
net.core.rmem_default <span class="o">=</span> <span class="m">8388608</span>
<span class="c1">#为TCP socket预留用于接收缓冲的内存最大值（单位：字节）</span>
net.core.rmem_max <span class="o">=</span> <span class="m">16777216</span>
<span class="c1">#每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目</span>
net.core.netdev_max_backlog <span class="o">=</span> <span class="m">262144</span>
<span class="c1">#web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值</span>
net.core.somaxconn <span class="o">=</span> <span class="m">262144</span>
<span class="c1">#系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)</span>
net.ipv4.tcp_max_orphans <span class="o">=</span> <span class="m">3276800</span>
<span class="c1">#记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128</span>
net.ipv4.tcp_max_syn_backlog <span class="o">=</span> <span class="m">262144</span>
<span class="c1">#时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉</span>
net.ipv4.tcp_timestamps <span class="o">=</span> <span class="m">0</span>
<span class="c1">#为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量</span>
net.ipv4.tcp_synack_retries <span class="o">=</span> <span class="m">1</span>
<span class="c1"># 使用cookie来处理SYN队列溢出</span>
net.ipv4.tcp_syncookies <span class="o">=</span> <span class="m">1</span> <span class="o">(</span><span class="m">0</span> by default<span class="o">)</span>
<span class="c1"># 路由刷新频率</span>
net.ipv4.route.gc_timeout <span class="o">=</span> <span class="m">100</span>
<span class="c1">#在内核放弃建立连接之前发送SYN包的数量</span>
net.ipv4.tcp_syn_retries <span class="o">=</span> <span class="m">1</span>
<span class="c1">#开启TCP连接中time_wait sockets的快速回收</span>
net.ipv4.tcp_tw_recycle <span class="o">=</span> <span class="m">1</span>
<span class="c1">#开启TCP连接复用功能，允许将time_wait sockets重新用于新的TCP连接（主要针对time_wait连接）</span>
net.ipv4.tcp_tw_reuse <span class="o">=</span> <span class="m">1</span>
<span class="c1">#1st低于此值,TCP没有内存压力,2nd进入内存压力阶段,3rdTCP拒绝分配socket(单位：内存页)</span>
net.ipv4.udp_mem <span class="o">=</span> <span class="m">65536</span> <span class="m">131072</span> <span class="m">262144</span>  <span class="c1"># 增加可分配的最大总缓冲区空间,此为以page为单位（4096字节）测量</span>
net.ipv4.tcp_mem <span class="o">=</span> <span class="m">65536</span> <span class="m">131072</span> <span class="m">262144</span>
<span class="c1">#如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60 秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。</span>
net.ipv4.tcp_fin_timeout <span class="o">=</span> <span class="m">15</span>   <span class="c1"># (默认60s，建议15-30s)</span>
<span class="c1">#表示当keepalive起用的时候，TCP发送keepalive消息的频度（单位：秒）</span>
net.ipv4.tcp_keepalive_time <span class="o">=</span> <span class="m">300</span>
<span class="c1"># 确定了isAlive间隔探测之间的等待时间   (默认75s,建议15-30s)</span>
net.ipv4.tcp_keepalive_intvl <span class="o">=</span> <span class="m">15</span>
<span class="c1"># 超时之前的探测次数    # 默认值：9，推荐5</span>
net.ipv4.tcp_keepalive_probes <span class="o">=</span> <span class="m">5</span>
<span class="c1">#对外连接端口范围，RHEL 7 default: 32768 61000</span>
net.ipv4.ip_local_port_range <span class="o">=</span> <span class="m">2048</span> <span class="m">65000</span>
<span class="c1"># 防止TCP时间等待</span>
net.ipv4.tcp_rfc1337 <span class="o">=</span> <span class="m">1</span>
<span class="c1">#表示文件句柄的最大数量</span>
fs.file-max <span class="o">=</span> <span class="m">102400</span>

<span class="c1">#iptables 防火墙</span>
<span class="nb">echo</span> -e <span class="s2">&quot;net.nf_conntrack_max = 25000000&quot;</span> &gt;&gt; /etc/sysctl.conf
<span class="nb">echo</span> -e <span class="s2">&quot;net.netfilter.nf_conntrack_max = 25000000&quot;</span> &gt;&gt; /etc/sysctl.conf
<span class="nb">echo</span> -e <span class="s2">&quot;net.netfilter.nf_conntrack_tcp_timeout_established = 180&quot;</span> &gt;&gt; /etc/sysctl.conf
<span class="nb">echo</span> -e <span class="s2">&quot;net.netfilter.nf_conntrack_tcp_timeout_time_wait = 30&quot;</span> &gt;&gt; /etc/sysctl.conf
<span class="nb">echo</span> -e <span class="s2">&quot;net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60&quot;</span> &gt;&gt; /etc/sysctl.conf
<span class="nb">echo</span> -e <span class="s2">&quot;net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 30&quot;</span> &gt;&gt; /etc/sysctl.conf
</pre></div>

<p>优化参数详解：颜色表示常用优化参数
根据参数文件所处目录不同而进行分表整理</p>
<p>下列文件所在目录：/proc/sys/net/ipv4/</p>
<p>| 名称 | 默认值 | 建议值 | 描述 |
| :------: | :------: | :------: | :------: | :------: |
| <code class="codehilite">tcp_syn_retries</code> | 5 | 1 | 对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃。不应该大于255，默认值是5，对应于180秒左右时间。。对于大负载而物理通信良好的网络而言,这个值偏高,可修改为2.这个值仅仅是针对对外的连接,对进来的连接,是由tcp_retries1决定的 |
| <code class="codehilite">tcp_synack_retries</code> | 5 | 1 | 对于远端的连接请求SYN，内核会发送SYN ＋ ACK数据报，以确认收到上一个 SYN连接请求包。这是所谓的三次握手 threeway handshake机制的第二个步骤。这里决定内核在放弃连接之前所送出的 SYN+ACK 数目。不应该大于255，默认值是5，对应于180秒左右时间。 |
| <code class="codehilite">tcp_keepalive_time</code> | 7200 | 600 | TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效。 |
|  |  |  | 防止两边建立连接但不发送数据的攻击。 |
| <code class="codehilite">tcp_keepalive_probes</code> | 9 | 3 | TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效。 |
| <code class="codehilite">tcp_keepalive_intvl</code> | 75 | 15 | 探测消息未获得响应时，重发该消息的间隔时间（秒）。默认值为75秒。 对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值 |
| tcp_retries1 | 3 | 3 | 放弃回应一个TCP连接请求前﹐需要进行多少次重试。RFC 规定最低的数值是3 |
| <code class="codehilite">tcp_retries2</code> | 15 | 5 | 在丢弃激活已建立通讯状况的TCP连接之前﹐需要进行多少次重试。默认值为15，根据RTO的值来决定，相当于13-30分钟RFC1122规定，必须大于100秒.这个值根据目前的网络设置,可以适当地改小,我的网络内修改为了5 |
| tcp_orphan_retries | 7 | 3 | 在近端丢弃TCP连接之前﹐要进行多少次重试。默认值是7个﹐相当于 50秒 - 16分钟﹐视RTO 而定。如果您的系统是负载很大的web服务器﹐那么也许需要降低该值﹐这类 sockets 可能会耗费大量的资源。另外参的考tcp_max_orphans。事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为3 |
| <code class="codehilite">tcp_fin_timeout</code> | 60 | 2 | 对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。默认值为 60 秒。 |
| <code class="codehilite">tcp_max_tw_buckets</code> | 180000 | 36000 | 系统在同时所处理的最大 timewait sockets 数目。如果超过此数的话﹐time-wait socket 会被立即砍除并且显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐不过﹐如果网络条件需要比默认值更多﹐则可以提高它或许还要增加内存。事实上做NAT的时候最好可以适当地增加该值 |
| <code class="codehilite">tcp_tw_recycle</code> | 0 | 1 | 打开快速 TIME-WAIT sockets 回收。除非得到技术专家的建议或要求﹐请不要随意修改这个值。做NAT的时候，建议打开它 |
| <code class="codehilite">tcp_tw_reuse</code> | 0 | 1 | 表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助 |
| <code class="codehilite">tcp_max_orphans</code> | 8192 | 32768 | 系统所能处理不属于任何进程的TCP sockets最大数量。假如超过这个数量﹐那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要依赖这个或是人为的降低这个限制。如果内存大更应该增加这个值。这个值Redhat AS版本中设置为32768,但是很多防火墙修改的时候,建议该值修改为2000 |
| tcp_abort_on_overflow | 0 | 0 | 当守护进程太忙而不能接受新的连接，就象对方发送reset消息，默认值是false。这意味着当溢出的原因是因为一个偶然的猝发，那么连接将恢复状态。只有在你确信守护进程真的不能完成连接请求时才打开该选项，该选项会影响客户的使用。对待已经满载的sendmail,apache这类服务的时候,这个可以很快让客户端终止连接,可以给予服务程序处理已有连接的缓冲机会,所以很多防火墙上推荐打开它 |
| <code class="codehilite">tcp_syncookies</code> | 0 | 1 | 只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用。当出现syn等候队列出现溢出时象对方发送syncookies。目的是为了防止syn flood攻击。 |
| tcp_stdurg | 0 | 0 | 使用 TCP urg pointer 字段中的主机请求解释功能。大部份的主机都使用老旧的 BSD解释，因此如果您在 Linux 打开它﹐或会导致不能和它们正确沟通。 |
| <code class="codehilite">tcp_max_syn_backlog</code> | 1024 | 16384 | 对于那些依然还未获得客户端确认的连接请求﹐需要保存在队列中最大数目。对于超过 128Mb 内存的系统﹐默认值是 1024 ﹐低于 128Mb 的则为 128。如果服务器经常出现过载﹐可以尝试增加这个数字。警告﹗假如您将此值设为大于 1024﹐最好修改include/net/tcp.h里面的TCP_SYNQ_HSIZE﹐以保持TCP_SYNQ_HSIZE*16SYN Flood攻击利用TCP协议散布握手的缺陷，伪造虚假源IP地址发送大量TCP-SYN半打开连接到目标系统，最终导致目标系统Socket队列资源耗尽而无法接受新的连接。为了应付这种攻击，现代Unix系统中普遍采用多连接队列处理的方式来缓冲而不是解决这种攻击，是用一个基本队列处理正常的完全连接应用Connect和Accept ，是用另一个队列单独存放半打开连接。这种双队列处理方式和其他一些系统内核措施例如Syn-Cookies/Caches联合应用时，能够比较有效的缓解小规模的SYN Flood攻击事实证明 |
| tcp_window_scaling | 1 | 1 | 该文件表示设置tcp/ip会话的滑动窗口大小是否可变。参数值为布尔值，为1时表示可变，为0时表示不可变。tcp/ip通常使用的窗口最大可达到 65535 字节，对于高速网络，该值可能太小，这时候如果启用了该功能，可以使tcp/ip滑动窗口大小增大数个数量级，从而提高数据传输的能力RFC 1323。（对普通地百M网络而言，关闭会降低开销，所以如果不是高速网络，可以考虑设置为0） |
| tcp_timestamps | 1 | 1 | Timestamps 用在其它一些东西中﹐可以防范那些伪造的 sequence 号码。一条1G的宽带线路或许会重遇到带 out-of-line数值的旧sequence 号码假如它是由于上次产生的。Timestamp 会让它知道这是个 '旧封包'。该文件表示是否启用以一种比超时重发更精确的方法（RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。 |
| tcp_sack | 1 | 1 | 使用 Selective ACK﹐它可以用来查找特定的遗失的数据报--- 因此有助于快速恢复状态。该文件表示是否启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）。对于广域网通信来说这个选项应该启用，但是这会增加对 CPU 的占用。 |
| tcp_fack | 1 | 1 | 打开FACK拥塞避免和快速重传功能。注意，当tcp_sack设置为0的时候，这个值即使设置为1也无效[这个是TCP连接靠谱的核心功能] |
| tcp_dsack | 1 | 1 | 允许TCP发送"两个完全相同"的SACK。 |
| tcp_ecn | 0 | 0 | TCP的直接拥塞通告功能。 |
| tcp_reordering | 3 | 6 | TCP流中重排序的数据报最大数量。 一般有看到推荐把这个数值略微调整大一些,比如5 |
| tcp_retrans_collapse | 1 | 0 | 对于某些有bug的打印机提供针对其bug的兼容性。一般不需要这个支持,可以关闭它 |
| <code class="codehilite">tcp_wmem：mindefaultmax</code> | 4096 | 8192 | 发送缓存设置 |
|  | 16384 | 131072 | min：为TCP socket预留用于发送缓冲的内存最小值。每个tcp socket都可以在建议以后都可以使用它。默认值为40964K。 |
|  | 131072 | 16777216 | default：为TCP socket预留用于发送缓冲的内存数量，默认情况下该值会影响其它协议使用的net.core.wmem_default 值，一般要低于net.core.wmem_default的值。默认值为1638416K。 |
|  |  |  | max: 用于TCP socket发送缓冲的内存最大值。该值不会影响net.core.wmem_max，"静态"选择参数SO_SNDBUF则不受该值影响。默认值为131072128K。（对于服务器而言，增加这个参数的值对于发送数据很有帮助,在我的网络环境中,修改为了51200 131072 204800） |
| <code class="codehilite">tcp_rmem：mindefaultmax</code> | 4096 | 32768 | 接收缓存设置 |
|  | 87380 | 131072 | 同tcp_wmem |
|  | 174760 | 16777216 |  |
| <code class="codehilite">tcp_mem：mindefaultmax</code> | 根据内存计算 | 786432 | low：当TCP使用了低于该值的内存页面数时，TCP不会考虑释放内存。即低于此值没有内存压力。理想情况下，这个值应与指定给 tcp_wmem 的第 2 个值相匹配 - 这第 2 个值表明，最大页面大小乘以最大并发请求数除以页大小 131072 * 300 / 4096。  |
|  |  | 1048576 1572864 | pressure：当TCP使用了超过该值的内存页面数量时，TCP试图稳定其内存使用，进入pressure模式，当内存消耗低于low值时则退出pressure状态。理想情况下这个值应该是 TCP 可以使用的总缓冲区大小的最大值 204800 * 300 / 4096。  |
|  |  |  | high：允许所有tcp sockets用于排队缓冲数据报的页面量。如果超过这个值，TCP 连接将被拒绝，这就是为什么不要令其过于保守 512000 * 300 / 4096 的原因了。 在这种情况下，提供的价值很大，它能处理很多连接，是所预期的 2.5 倍；或者使现有连接能够传输 2.5 倍的数据。 我的网络里为192000 300000 732000 |
|  |  |  | 一般情况下这些值是在系统启动时根据系统内存数量计算得到的。 |
| tcp_app_win | 31 | 31 | 保留maxwindow/2^tcp_app_win, mss数量的窗口由于应用缓冲。当为0时表示不需要缓冲。 |
| tcp_adv_win_scale | 2 | 2 | 计算缓冲开销bytes/2^tcp_adv_win_scale如果tcp_adv_win_scale &gt; 0或者bytes-bytes/2^-tcp_adv_win_scale如果tcp_adv_win_scale BOOLEAN&gt;0 |
| tcp_low_latency | 0 | 0 | 允许 TCP/IP 栈适应在高吞吐量情况下低延时的情况；这个选项一般情形是的禁用。但在构建Beowulf 集群的时候,打开它很有帮助 |
| tcp_westwood | 0 | 0 | 启用发送者端的拥塞控制算法，它可以维护对吞吐量的评估，并试图对带宽的整体利用情况进行优化；对于 WAN 通信来说应该启用这个选项。 |
| tcp_bic | 0 | 0 | 为快速长距离网络启用 Binary Increase Congestion；这样可以更好地利用以 GB 速度进行操作的链接；对于 WAN 通信应该启用这个选项。 |
| ip_forward | 0 | － | NAT必须开启IP转发支持，把该值写1 |
| <code class="codehilite"><span class="n">ip_local_port_range</span><span class="o">:</span><span class="n">minmax</span></code> | 32768 | 1024 | 表示用于向外连接的端口范围，默认比较小，这个范围同样会间接用于NAT表规模。 |
|  | 61000 | 65000 |  |
| <code class="codehilite">ip_conntrack_max</code> | 65535 | 65535 | 系统支持的最大ipv4连接数，默认65536（事实上这也是理论最大值），同时这个值和你的内存大小有关，如果内存128M，这个值最大8192，1G以上内存这个值都是默认65536 |</p>
<p>所处目录/proc/sys/net/ipv4/netfilter/</p>
<p>文件需要打开防火墙才会存在</p>
<p>| 名称 | 默认值 | 建议值 | 描述 |
| :------: | :------: | :------: | :------: | :------: |
| <code class="codehilite">ip_conntrack_max</code> | 65536 | 65536 | 系统支持的最大ipv4连接数，默认65536（事实上这也是理论最大值），同时这个值和你的内存大小有关，如果内存128M，这个值最大8192，1G以上内存这个值都是默认65536,这个值受/proc/sys/net/ipv4/ip_conntrack_max限制 |
| <code class="codehilite">ip_conntrack_tcp_timeout_established</code> | 432000 | 180 | 已建立的tcp连接的超时时间，默认432000，也就是5天。影响：这个值过大将导致一些可能已经不用的连接常驻于内存中，占用大量链接资源，从而可能导致NAT ip_conntrack: table full的问题。建议：对于NAT负载相对本机的 NAT表大小很紧张的时候，可能需要考虑缩小这个值，以尽早清除连接，保证有可用的连接资源；如果不紧张，不必修改 |
| <code class="codehilite">ip_conntrack_tcp_timeout_time_wait</code> | 120 | 120 | time_wait状态超时时间，超过该时间就清除该连接 |
| ip_conntrack_tcp_timeout_close_wait | 60 | 60 | close_wait状态超时时间，超过该时间就清除该连接 |
| ip_conntrack_tcp_timeout_fin_wait | 120 | 120 | fin_wait状态超时时间，超过该时间就清除该连接 |</p>
<p>文件所处目录/proc/sys/net/core/</p>
<p>| 名称 | 默认值 | 建议值 | 描述 |
| :------: | :------: | :------: | :------: | :------: |
| <code class="codehilite">netdev_max_backlog</code> | 1024 | 16384 | 每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目，对重负载服务器而言，该值需要调高一点。 |
| <code class="codehilite">somaxconn</code> | 128 | 16384 | 用来限制监听LISTEN队列最大数据包的数量，超过这个数量就会导致链接超时或者触发重传机制。 |
|  |  |  | web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。对繁忙的服务器,增加该值有助于网络性能 |
| <code class="codehilite">wmem_default</code> | 129024 | 129024 | 默认的发送窗口大小（以字节为单位） |
| rmem_default | 129024 | 129024 | 默认的接收窗口大小（以字节为单位） |
| <code class="codehilite">rmem_max</code> | 129024 | 873200 | 最大的TCP数据接收缓冲 |
| wmem_max | 129024 | 873200 | 最大的TCP数据发送缓冲 |</p>
<h2 id="root">赋予root权限<a class="headerlink" href="#root" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span>方法一： 修改 /etc/sudoers 文件，找到%wheel一行，把前面的注释（#）去掉
Allows people in group wheel to run all commands
%wheel    <span class="nv">ALL</span><span class="o">=(</span>ALL<span class="o">)</span>    ALL
然后修改用户，使其属于root组（wheel），命令如下：
<span class="c1">#usermod -g root tommy</span>
修改完毕，现在可以用tommy帐号登录，然后用命令 sudo su - ，即可获得root权限进行操作。
方法二： 修改 /etc/sudoers 文件，找到root一行，在root下面添加一行，如下所示：
Allow root to run any commands anywhere
root    <span class="nv">ALL</span><span class="o">=(</span>ALL<span class="o">)</span>     ALL
tommy   <span class="nv">ALL</span><span class="o">=(</span>ALL<span class="o">)</span>     ALL
修改完毕，现在可以用tommy帐号登录，然后用命令 sudo su - ，即可获得root权限进行操作。
方法三： 修改 /etc/passwd 文件，找到如下行，把用户ID修改为 <span class="m">0</span> ，如下所示：
tommy:x:500:500:tommy:/home/tommy:/bin/bash
修改后如下
tommy:x:0:500:tommy:/home/tommy:/bin/bash
保存，用tommy账户登录后，直接获取的就是root帐号的权限。
建议使用方法二，不要轻易使用方法三。
</pre></div>

<h2 id="_3">服务器配置双机信任<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span>服务器1的IP：192.168.1.1
服务器2的IP：192.168.1.2
在两台服务器上都按照以下步骤操作
<span class="c1"># 创建公钥和密钥</span>
ssh-keygen -t rsa
<span class="c1"># 将自己的公钥追加到认证公钥</span>
cat ~/.ssh/id_rsa.pub &gt;&gt; authorized_keys
在服务器1上操作
<span class="c1"># 将服务器2的公钥追加到认证公钥</span>
ssh <span class="m">192</span>.168.1.2 cat ~/.ssh/id_rsa.pub &gt;&gt; authorized_keys
在服务器2上操作
<span class="c1"># 将服务器1的公钥追加到认证公钥</span>
ssh <span class="m">192</span>.168.1.1 cat ~/.ssh/id_rsa.pub &gt;&gt; authorized_keys
测试
<span class="c1"># 在服务器1上执行下面的命令，如果配置正确的话就无需输入密码也能显示服务器2的网卡信息</span>
ssh <span class="m">192</span>.168.1.2 ifconfig
</pre></div>

<h2 id="-float-ip">未采用双机热备防止服务中断--float IP<a class="headerlink" href="#-float-ip" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span>有两台Linux服务器，其中一台主机（IP：139.24.214.22）对外提供了一定的网络服务，另一台从机（IP：139.24.214.24）能提供相同的服务，但IP地址没有对外部公开。
客户端连接的都是139.24.214.22这个IP地址，如果主机故障，则会使网络服务暂时中断，时间越长造成损失越大，
由于没有采用双机热备份技术,考虑自己用Linux脚本来实现简单的浮动IP技术，当主机故障时从机获得139.24.214.22这个IP，暂时替代主机提供服务，当主机恢复时，从机自动释放这个IP。
思路：
利用单个网卡绑定多个IP地址的技术和crontab自动执行技术
为主机的网卡多绑定一个静态IP，如139.24.214.82,这个地址是便于从机判断的，
为从机的网卡多绑定一个动态IP，127.0.0.1，它在主机故障时将会被脚本修改为139.24.214.22
在从机上添加一个脚本 /root/autoFloatIP.sh，使用crontab技术让这个脚本每分钟执行一次，这个脚本的作用是判断主机的地址82能否Ping通，一旦不正常则将让自己的网卡多余的那个IP地址改为139.24.214.22，如果主机恢复，则将这个地址改回为127.0.0.1

步骤
<span class="m">1</span>. 为主机添加一个静态IP139.24.214.82，由于这个是静态IP，可以采用在图形化界面中设置此IP并保存的办法，或者在/etc/sysconfig/network-scripts目录里面创建一个名为ifcfg-eth0:1的文件，内容为:

<span class="nv">DEVICE</span><span class="o">=</span>eth0:1
<span class="nv">IPADDR</span><span class="o">=</span><span class="m">139</span>.24.214.82
<span class="nv">NETMASK</span><span class="o">=</span> <span class="m">255</span>.255.255.0
<span class="nv">ONBOOT</span><span class="o">=</span> yes

<span class="m">2</span>. 在从机上，在/root下建立一个脚本autoFloatIP.sh
用chmod +x autoFloatIP.sh让它可以执行，脚本的内容为

<span class="c1">#!/bin/bash</span>
<span class="nv">c1</span><span class="o">=</span><span class="k">$(</span>ping <span class="m">139</span>.24.214.82 -c <span class="m">1</span><span class="p">|</span>grep Unreachable<span class="p">|</span>wc -l<span class="k">)</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$c1</span> -gt <span class="m">0</span> <span class="o">]</span> <span class="p">;</span> <span class="k">then</span>
<span class="nv">c2</span><span class="o">=</span><span class="k">$(</span>ping <span class="m">139</span>.24.214.82 -c <span class="m">10</span><span class="p">|</span>grep Unreachable<span class="p">|</span>wc -l<span class="k">)</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$c2</span> -gt <span class="m">9</span> <span class="o">]</span> <span class="p">;</span> <span class="k">then</span>
    <span class="nv">c3</span><span class="o">=</span><span class="k">$(</span>ping <span class="m">139</span>.24.214.22 -c <span class="m">10</span><span class="p">|</span>grep Unreachable<span class="p">|</span>wc -l<span class="k">)</span>
      <span class="k">if</span> <span class="o">[</span> <span class="nv">$c3</span> -gt <span class="m">9</span> <span class="o">]</span> <span class="p">;</span> <span class="k">then</span>
         /sbin/ifconfig eth0:1 <span class="m">139</span>.24.214.22 netmask <span class="m">255</span>.255.254.0
<span class="nb">echo</span> <span class="s2">&quot;float ip to 22&quot;</span>
      <span class="k">fi</span>
<span class="k">fi</span>
<span class="nb">echo</span> <span class="s2">&quot;can not connect&quot;</span>
<span class="k">else</span>
<span class="nv">c4</span><span class="o">=</span><span class="k">$(</span>/sbin/ifconfig<span class="p">|</span>grep <span class="m">139</span>.24.214.22<span class="p">|</span>wc -l<span class="k">)</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$c4</span> -gt <span class="m">0</span> <span class="o">]</span> <span class="p">;</span> <span class="k">then</span>
    /sbin/ifconfig eth0:2 <span class="m">127</span>.0.0.1 netmask <span class="m">255</span>.255.254.0
    <span class="nb">echo</span> <span class="s2">&quot;reset ip&quot;</span>
<span class="k">fi</span>
<span class="nb">echo</span> <span class="s2">&quot;connection is ok&quot;</span>
<span class="k">fi</span>

其中关键的命令为
/sbin/ifconfig eth0:1 <span class="m">139</span>.24.214.22 netmask <span class="m">255</span>.255.254.0
/sbin/ifconfig eth0:2 <span class="m">127</span>.0.0.1 netmask <span class="m">255</span>.255.254.0
用这个方法来动态修改IP，动态IP在电脑重启会消失

<span class="m">3</span>. 从机上建立crontab
用crontab -e命令
让后加上这样的一行并保存
* * * * * /root/autoFloatIP.sh &gt; /dev/null <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span>
</pre></div>

<h2 id="centosip">升级centos内核&amp;更改为静态ip、网卡名称<a class="headerlink" href="#centosip" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><span class="m">1</span>、导入key（内核3.0以上需要导入key）
rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
当然，如果已经修改了repo的gpgcheck<span class="o">=</span>0也可以不导入key
<span class="m">2</span>、安装elrepo的yum源
To install ELRepo <span class="k">for</span> RHEL-7, SL-7 or CentOS-7:
rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm <span class="o">(</span>external link<span class="o">)</span>
To make use of our mirror system, please also install yum-plugin-fastestmirror.
To install ELRepo <span class="k">for</span> RHEL-6, SL-6 or CentOS-6:
rpm -Uvh http://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm
<span class="m">3</span>、安装内核
在yum的ELRepo源中，有mainline颁布的，可以这样安装：
yum --enablerepo<span class="o">=</span>elrepo-kernel install  kernel-ml-devel kernel-ml -y
当然也可以安装long term的：
yum --enablerepo<span class="o">=</span>elrepo-kernel  install  kernel-lt -y
更改为静态IP：/etc/sysconfig/network-scripts/ifcfg-ens33
<span class="nv">BOOTPROTO</span><span class="o">=</span><span class="s2">&quot;static&quot;</span> <span class="c1">#dhcp改为static</span>
<span class="nv">ONBOOT</span><span class="o">=</span><span class="s2">&quot;yes&quot;</span> <span class="c1">#开机启用本配置</span>
<span class="nv">IPADDR</span><span class="o">=</span><span class="m">192</span>.168.7.106 <span class="c1">#静态IP</span>
<span class="nv">GATEWAY</span><span class="o">=</span><span class="m">192</span>.168.7.1 <span class="c1">#默认网关</span>
<span class="nv">NETMASK</span><span class="o">=</span><span class="m">255</span>.255.255.0 <span class="c1">#子网掩码</span>
<span class="nv">DNS1</span><span class="o">=</span><span class="m">192</span>.168.7.1 <span class="c1">#DNS 配置</span>
修改网卡名称样式为ethx：
<span class="m">1</span>、编辑 grub 配置文件
vim /etc/sysconfig/grub   <span class="c1"># 其实是/etc/default/grub的软连接</span>
<span class="c1"># 为GRUB_CMDLINE_LINUX变量增加2个参数，具体内容如下(加粗)：</span>
<span class="nv">GRUB_CMDLINE_LINUX</span><span class="o">=</span><span class="s2">&quot;crashkernel=auto rd.lvm.lv=cl/root rd.lvm.lv=cl/swap net.ifnames=0 biosdevname=0 rhgb quiet&quot;</span>
<span class="m">2</span>、重新生成 grub 配置文件
grub2-mkconfig -o /boot/grub2/grub.cfg
然后重新启动 Linux 操作系统，通过 ip addr 可以看到网卡名称已经变为 eth0 。
<span class="m">3</span>、修改网卡配置文件
原来网卡配置文件名称为 ifcfg-ens33，这里需要修改为 ethx 的格式，并适当调整网卡配置文件。
mv /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-eth0
<span class="c1"># 修改ifcfg-eth0文件如下内容(其它内容不变)</span>
<span class="nv">NAME</span><span class="o">=</span>eth0
<span class="nv">DEVICE</span><span class="o">=</span>eth0
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># systemctl restart network.service    # 重启网络服务</span>
注意：ifcfg-ens33 文件最好删除掉，否则重启 network 服务时候会报错<span class="o">}</span>
</pre></div>

<h2 id="ssh_1">SSH相关命令和配置<a class="headerlink" href="#ssh_1" title="Permanent link">&para;</a></h2>
<h3 id="ssh_2">SSH协议无密码登陆设定：<a class="headerlink" href="#ssh_2" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>在本机上生成RSA密码对：公钥和私钥；将公钥复制到要ssh的远程主机的用户的家目录（以root用户为例）；
<span class="m">1</span>，第一步生成密码对文件

<span class="o">[</span>root@tangsir ~<span class="o">]</span><span class="c1"># ssh-keygen</span>
Generating public/private rsa key pair.
Enter file in which to save the key <span class="o">(</span>/root/.ssh/id_rsa<span class="o">)</span>:
Enter passphrase <span class="o">(</span>empty <span class="k">for</span> no passphrase<span class="o">)</span>:
Enter same passphrase again:
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
<span class="m">57</span>:67:db:f8:6d:dc:d0:f4:fc:9a:68:95:16:10:ec:ab

<span class="o">[</span>root@tangsir ~<span class="o">]</span><span class="c1"># ls ~/.ssh</span>
id_rsa  id_rsa.pub  known_hosts

<span class="m">2</span>,复制公钥到远程主机
<span class="o">[</span>root@tangsir ~<span class="o">]</span><span class="c1"># ls /root/.ssh</span>
id_rsa  id_rsa.pub  known_hosts
<span class="o">[</span>root@tangsir ~<span class="o">]</span><span class="c1"># ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.1.101</span>
<span class="m">21</span>
root@192.168.1.101<span class="s1">&#39;s password:</span>
<span class="s1">Now try logging into the machine, with &quot;ssh &#39;</span>root@192.168.1.101<span class="s1">&#39;&quot;, and check in:</span>

<span class="s1">  .ssh/authorized_keys</span>

<span class="s1">to make sure we haven&#39;</span>t added extra keys that you weren<span class="err">&#39;</span>t expecting.

<span class="o">[</span>root@tangsir ~<span class="o">]</span><span class="c1"># ssh root@192.168.1.101</span>
Last login: Tue May <span class="m">21</span> <span class="m">08</span>:02:43 <span class="m">2013</span> from <span class="m">192</span>.168.1.101
不用输入远程主机用户的密码
</pre></div>

<h3 id="sshd_configetcsshsshd_config">sshd_config配置详解（/etc/ssh/sshd_config）<a class="headerlink" href="#sshd_configetcsshsshd_config" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="c1"># The strategy used for options in the default sshd_config shipped with</span>
<span class="c1"># OpenSSH is to specify options with their default value where</span>
<span class="c1"># possible, but leave them commented.  Uncommented options override the</span>
<span class="c1"># default value.</span>

<span class="c1">#</span>
<span class="c1"># AddressFamily指定sshd应当使用哪种地址族。取值范围是：&quot;any&quot;(默认)、&quot;inet&quot;(仅IPv4)、&quot;inet6&quot;(仅IPv6)。</span>
<span class="c1">#AddressFamily any</span>

<span class="c1"># 指定sshd监听的网络地址，默认监听所有地址。可以使用下面的格式：</span>
<span class="c1"># ListenAddress host|IPv4_addr|IPv6_addr</span>
<span class="c1"># ListenAddress host|IPv4_addr:port</span>
<span class="c1"># ListenAddress [host|IPv6_addr]:port</span>
<span class="c1"># 如果未指定 port ，那么将使用 Port 指令的值。</span>
<span class="c1"># 可以使用多个 ListenAddress 指令监听多个地址。</span>
<span class="c1">#ListenAddress 0.0.0.0</span>
<span class="c1">#ListenAddress ::</span>

<span class="c1"># HostKey</span>
<span class="c1"># 主机私钥文件的位置。如果权限不对，sshd可能会拒绝启动。</span>
<span class="c1"># SSH-1默认是 /etc/ssh/ssh_host_key 。</span>
<span class="c1"># SSH-2默认是 /etc/ssh/ssh_host_rsa_key 和 /etc/ssh/ssh_host_dsa_key 。</span>
<span class="c1"># 一台主机可以拥有多个不同的私钥。&quot;rsa1&quot;仅用于SSH-1，&quot;dsa&quot;和&quot;rsa&quot;仅用于SSH-2。</span>
<span class="c1">#HostKey /etc/ssh/ssh_host_rsa_key</span>
<span class="c1">#HostKey /etc/ssh/ssh_host_ecdsa_key</span>
<span class="c1">#HostKey /etc/ssh/ssh_host_ed25519_key</span>

<span class="c1"># 指定SSH-2允许使用的加密算法。多个算法之间使用逗号分隔。可以使用的算法如下：</span>
<span class="c1"># &quot;aes128-cbc&quot;, &quot;aes192-cbc&quot;, &quot;aes256-cbc&quot;, &quot;aes128-ctr&quot;, &quot;aes192-ctr&quot;, &quot;aes256-ctr&quot;,</span>
<span class="c1"># &quot;3des-cbc&quot;, &quot;arcfour128&quot;, &quot;arcfour256&quot;, &quot;arcfour&quot;, &quot;blowfish-cbc&quot;, &quot;cast128-cbc&quot;</span>
<span class="c1"># 默认值是可以使用上述所有算法。</span>
<span class="c1"># Ciphers and keying</span>
<span class="c1">#RekeyLimit default none</span>

<span class="c1"># 指定sshd将日志消息通过哪个日志子系统(facility)发送。有效值是：DAEMON, USER, AUTH(默认), LOCAL0, LOCAL1, LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL7</span>
<span class="c1"># Logging</span>
<span class="c1">#SyslogFacility AUTH</span>

<span class="c1"># 指定 sshd(8) 的日志等级(详细程度)。可用值如下：</span>
<span class="c1"># QUIET, FATAL, ERROR, INFO(默认), VERBOSE, DEBUG, DEBUG1, DEBUG2, DEBUG3</span>
<span class="c1"># DEBUG 与 DEBUG1 等价；DEBUG2 和 DEBUG3 则分别指定了更详细、更罗嗦的日志输出。</span>
<span class="c1"># 比 DEBUG 更详细的日志可能会泄漏用户的敏感信息，因此反对使用。</span>
<span class="c1">#LogLevel INFO</span>

<span class="c1"># Authentication:</span>

<span class="c1"># 限制用户必须在指定的时限内认证成功，0 表示无限制。默认值是 120 秒。</span>
<span class="c1">#LoginGraceTime 2m</span>

<span class="c1"># 是否允许 root 登录。可用值如下：</span>
<span class="c1"># &quot;yes&quot;(默认) 表示允许。&quot;no&quot;表示禁止。</span>
<span class="c1"># &quot;without-password&quot;表示禁止使用密码认证登录。</span>
<span class="c1"># &quot;forced-commands-only&quot;表示只有在指定了 command 选项的情况下才允许使用公钥认证登录。同时其它认证方法全部被禁止。这个值常用于做远程备份之类的事情。</span>
<span class="c1">#PermitRootLogin prohibit-password</span>

<span class="c1"># 指定是否要求sshd在接受连接请求前对用户主目录和相关的配置文件进行宿主和权限检查。强烈建议使用默认值&quot;yes&quot;来预防可能出现的低级错误</span>
<span class="c1">#StrictModes yes</span>

<span class="c1"># 指定每个连接最大允许的认证次数。默认值是 6 。</span>
<span class="c1"># 如果失败认证的次数超过这个数值的一半，连接将被强制断开，且会生成额外的失败日志消息。</span>
<span class="c1">#MaxAuthTries 6</span>

<span class="c1">#MaxSessions 10</span>

<span class="c1"># 是否允许公钥认证。仅可以用于SSH-2。默认值为&quot;yes&quot;。</span>
<span class="c1">#PubkeyAuthentication yes</span>

<span class="c1">######################################################################################################################</span>

<span class="c1"># 存放该用户可以用来登录的 RSA/DSA 公钥。</span>
<span class="c1"># 该指令中可以使用下列根据连接时的实际情况进行展开的符号：</span>
<span class="c1"># %% 表示&#39;%&#39;、%h 表示用户的主目录、%u 表示该用户的用户名。</span>
<span class="c1"># 经过扩展之后的值必须要么是绝对路径，要么是相对于用户主目录的相对路径。</span>
<span class="c1"># 默认值是&quot;.ssh/authorized_keys&quot;</span>
<span class="c1"># Expect .ssh/authorized_keys2 to be disregarded by default in future.</span>
<span class="c1">#AuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2</span>

<span class="c1">######################################################################################################################</span>

<span class="c1">#AuthorizedPrincipalsFile none</span>

<span class="c1">#AuthorizedKeysCommand none</span>
<span class="c1">#AuthorizedKeysCommandUser nobody</span>

<span class="c1"># 是否使用强可信主机认证(通过检查远程主机名和关联的用户名进行认证)。仅用于SSH-1。</span>
<span class="c1"># 这是通过在RSA认证成功后再检查 ~/.rhosts 或 /etc/hosts.equiv 进行认证的。</span>
<span class="c1"># 出于安全考虑，建议使用默认值&quot;no&quot;</span>
<span class="c1">#RhostsRSAAuthentication</span>

<span class="c1"># 这个指令与 RhostsRSAAuthentication 类似，但是仅可以用于SSH-2。推荐使用默认值&quot;no&quot;。</span>
<span class="c1"># 推荐使用默认值&quot;no&quot;禁止这种不安全的认证方式。</span>
<span class="c1"># For this to work you will also need host keys in /etc/ssh/ssh_known_hosts</span>
<span class="c1">#HostbasedAuthentication no</span>

<span class="c1">#HostbasedUsesNameFromPacketOnly</span>
<span class="c1"># 在开启 HostbasedAuthentication 的情况下，</span>
<span class="c1"># 指定服务器在使用 ~/.shosts ~/.rhosts /etc/hosts.equiv 进行远程主机名匹配时，是否进行反向域名查询。</span>
<span class="c1"># &quot;yes&quot;表示sshd信任客户端提供的主机名而不进行反向查询。默认值是&quot;no&quot;。</span>

<span class="c1"># 是否在 RhostsRSAAuthentication 或 HostbasedAuthentication 过程中忽略用户的 ~/.ssh/known_hosts 文件。</span>
<span class="c1"># 默认值是&quot;no&quot;。为了提高安全性，可以设为&quot;yes&quot;。</span>
<span class="c1"># Change to yes if you don&#39;t trust ~/.ssh/known_hosts for</span>
<span class="c1"># HostbasedAuthentication</span>
<span class="c1">#IgnoreUserKnownHosts no</span>

<span class="c1"># 是否在 RhostsRSAAuthentication 或 HostbasedAuthentication 过程中忽略 .rhosts 和 .shosts 文件。</span>
<span class="c1"># 不过 /etc/hosts.equiv 和 /etc/shosts.equiv 仍将被使用。推荐设为默认值&quot;yes&quot;。</span>
<span class="c1"># Don&#39;t read the user&#39;s ~/.rhosts and ~/.shosts files</span>
<span class="c1">#IgnoreRhosts yes</span>


<span class="c1"># To disable tunneled clear text passwords, change to no here!</span>

<span class="c1"># 是否允许使用基于密码的认证。默认为&quot;yes&quot;。</span>
<span class="c1">#PasswordAuthentication yes</span>

是否允许密码为空的用户远程登录。默认为<span class="s2">&quot;no&quot;</span>
<span class="c1">#PermitEmptyPasswords no</span>

<span class="c1"># 是否允许质疑-应答(challenge-response)认证。默认值是&quot;yes&quot;</span>
<span class="c1"># 所有 login.conf(5) 中允许的认证方式都被支持。</span>
<span class="c1"># Change to yes to enable challenge-response passwords (beware issues with</span>
<span class="c1"># some PAM modules and threads)</span>
ChallengeResponseAuthentication no

<span class="c1"># Kerberos options</span>

<span class="c1"># 是否要求用户为 PasswordAuthentication 提供的密码必须通过 Kerberos KDC 认证，也就是是否使用Kerberos认证。</span>
<span class="c1"># 要使用Kerberos认证，服务器需要一个可以校验 KDC identity 的 Kerberos servtab 。默认值是&quot;no&quot;。</span>
<span class="c1">#KerberosAuthentication no</span>

<span class="c1"># 如果 Kerberos 密码认证失败，那么该密码还将要通过其它的认证机制(比如 /etc/passwd)。</span>
<span class="c1"># 默认值为&quot;yes&quot;。</span>
<span class="c1">#KerberosOrLocalPasswd yes</span>

<span class="c1"># 是否在用户退出登录后自动销毁用户的 ticket 。默认值是&quot;yes&quot;。</span>
<span class="c1">#KerberosTicketCleanup yes</span>

<span class="c1"># 如果使用了 AFS 并且该用户有一个 Kerberos 5 TGT，那么开启该指令后，</span>
<span class="c1"># 将会在访问用户的家目录前尝试获取一个 AFS token 。默认为&quot;no&quot;。</span>
<span class="c1">#KerberosGetAFSToken no</span>

<span class="c1"># GSSAPI options</span>

<span class="c1"># 是否允许使用基于 GSSAPI 的用户认证。默认值为&quot;no&quot;。仅用于SSH-2。</span>
<span class="c1">#GSSAPIAuthentication no</span>

是否在用户退出登录后自动销毁用户凭证缓存。默认值是<span class="s2">&quot;yes&quot;</span>。仅用于SSH-2。
<span class="c1">#GSSAPICleanupCredentials yes</span>


<span class="c1">#GSSAPIStrictAcceptorCheck yes</span>
<span class="c1">#GSSAPIKeyExchange no</span>

<span class="c1"># Set this to &#39;yes&#39; to enable PAM authentication, account processing,</span>
<span class="c1"># and session processing. If this is enabled, PAM authentication will</span>
<span class="c1"># be allowed through the ChallengeResponseAuthentication and</span>
<span class="c1"># PasswordAuthentication.  Depending on your PAM configuration,</span>
<span class="c1"># PAM authentication via ChallengeResponseAuthentication may bypass</span>
<span class="c1"># the setting of &quot;PermitRootLogin without-password&quot;.</span>
<span class="c1"># If you just want the PAM account and session checks to run without</span>
<span class="c1"># PAM authentication, then enable this but set PasswordAuthentication</span>
<span class="c1"># and ChallengeResponseAuthentication to &#39;no&#39;.</span>
UsePAM yes

<span class="c1">#AllowAgentForwarding yes</span>

<span class="c1"># 是否允许TCP转发，默认值为&quot;yes&quot;。</span>
<span class="c1"># 禁止TCP转发并不能增强安全性，除非禁止了用户对shell的访问，因为用户可以安装他们自己的转发器。</span>
<span class="c1">#AllowTcpForwarding yes</span>

<span class="c1">######################################################################################################################</span>

<span class="c1"># GatewayPorts</span>
<span class="c1"># 是否允许远程主机连接本地的转发端口。默认值是&quot;no&quot;。</span>
<span class="c1"># sshd(8) 默认将远程端口转发绑定到loopback地址。这样将阻止其它远程主机连接到转发端口。</span>
<span class="c1"># GatewayPorts 指令可以让 sshd 将远程端口转发绑定到非loopback地址，这样就可以允许远程主机连接了。</span>
<span class="c1"># &quot;no&quot;表示仅允许本地连接，&quot;yes&quot;表示强制将远程端口转发绑定到统配地址(wildcard address)，</span>
<span class="c1"># &quot;clientspecified&quot;表示允许客户端选择将远程端口转发绑定到哪个地址。</span>
<span class="c1">#GatewayPorts no</span>

<span class="c1">######################################################################################################################</span>

<span class="c1"># 是否允许进行 X11 转发。默认值是&quot;no&quot;，设为&quot;yes&quot;表示允许。</span>
<span class="c1"># 如果允许X11转发并且sshd(8)代理的显示区被配置为在含有通配符的地址(X11UseLocalhost)上监听。</span>
<span class="c1"># 那么将可能有额外的信息被泄漏。由于使用X11转发的可能带来的风险，此指令默认值为&quot;no&quot;。</span>
<span class="c1"># 需要注意的是，禁止X11转发并不能禁止用户转发X11通信，因为用户可以安装他们自己的转发器。</span>
<span class="c1"># 如果启用了 UseLogin ，那么X11转发将被自动禁止。</span>
X11Forwarding yes

<span class="c1"># 指定sshdX11 转发的第一个可用的显示区(display)数字。默认值是 10 。</span>
<span class="c1"># 这个可以用于防止 sshd 占用了真实的 X11 服务器显示区，从而发生混淆</span>
<span class="c1">#X11DisplayOffset 10</span>

<span class="c1"># sshd是否应当将X11转发服务器绑定到本地loopback地址。默认值是&quot;yes&quot;。</span>
<span class="c1"># sshd 默认将转发服务器绑定到本地loopback地址并将 DISPLAY 环境变量的主机名部分设为&quot;localhost&quot;。</span>
<span class="c1"># 这可以防止远程主机连接到 proxy display 。不过某些老旧的X11客户端不能在此配置下正常工作。</span>
<span class="c1"># 为了兼容这些老旧的X11客户端，你可以设为&quot;no&quot;</span>
<span class="c1">#X11UseLocalhost yes</span>
<span class="c1">#PermitTTY yes</span>

<span class="c1"># 指定sshd是否在每一次交互式登录时打印 /etc/motd 文件的内容。默认值是&quot;yes&quot;。</span>
PrintMotd no

<span class="c1"># 指定sshd是否在每一次交互式登录时打印最后一位用户的登录时间。默认值是&quot;yes&quot;。</span>
<span class="c1">#PrintLastLog yes</span>

<span class="c1"># 指定系统是否向客户端发送 TCPkeepalive消息。默认值是&quot;yes&quot;。这种消息可以检测到死连接、连接不当关闭、客户端崩溃等异常。可以设为&quot;no&quot;关闭这个特性。</span>
<span class="c1">#TCPKeepAlive yes</span>

<span class="c1"># 是否在交互式会话的登录过程中使用 login(1) 。默认值是&quot;no&quot;。</span>
<span class="c1"># 如果开启此指令，那么 X11Forwarding 将会被禁止，因为 login(1) 不知道如何处理 xauth(1) cookies 。</span>
<span class="c1"># 需要注意的是，login(1) 是禁止用于远程执行命令的。</span>
<span class="c1"># 如果指定了 UsePrivilegeSeparation ，那么它将在认证完成后被禁用。</span>
<span class="c1">#UseLogin no</span>

是否让sshd通过创建非特权子进程处理接入请求的方法来进行权限分离。默认值是<span class="s2">&quot;yes&quot;</span>。
认证成功后，将以该认证用户的身份创建另一个子进程。
这样做的目的是为了防止通过有缺陷的子进程提升权限，从而使系统更加安全。
<span class="c1">#UsePrivilegeSeparation sandbox</span>

<span class="c1"># 指定是否允许 sshd(8) 处理 ~/.ssh/environment 以及 ~/.ssh/authorized_keys 中的 environment= 选项。</span>
<span class="c1"># 默认值是&quot;no&quot;。如果设为&quot;yes&quot;可能会导致用户有机会使用某些机制(比如 LD_PRELOAD)绕过访问控制，造成安全漏洞。</span>
<span class="c1">#PermitUserEnvironment no</span>

<span class="c1"># 是否对通信数据进行压缩，还是延迟到认证成功之后再对通信数据进行压缩。</span>
<span class="c1"># 可用值：&quot;yes&quot;, &quot;delayed&quot;(默认), &quot;no&quot;。</span>
<span class="c1">#Compression delayed</span>

<span class="c1">######################################################################################################################</span>

<span class="c1"># 设置一个以秒记的时长，如果超过这么长时间没有收到客户端的任何数据，</span>
<span class="c1"># sshd(8) 将通过安全通道向客户端发送一个&quot;alive&quot;消息，并等候应答。</span>
<span class="c1"># 默认值 0 表示不发送&quot;alive&quot;消息。这个选项仅对SSH-2有效。</span>
<span class="c1">#ClientAliveInterval 0</span>

<span class="c1">######################################################################################################################</span>

<span class="c1"># sshd在未收到任何客户端回应前最多允许发送多少个&quot;alive&quot;消息。默认值是 3 。</span>
<span class="c1"># 到达这个上限后，sshd(8) 将强制断开连接、关闭会话。</span>
<span class="c1"># 需要注意的是，&quot;alive&quot;消息与 TCPKeepAlive 有很大差异。</span>
<span class="c1"># &quot;alive&quot;消息是通过加密连接发送的，因此不会被欺骗；而 TCPKeepAlive 却是可以被欺骗的。</span>
<span class="c1"># 如果 ClientAliveInterval 被设为 15 并且将 ClientAliveCountMax 保持为默认值，</span>
<span class="c1"># 那么无应答的客户端大约会在45秒后被强制断开。这个指令仅可以用于SSH-2协议。</span>
<span class="c1">#ClientAliveCountMax 3</span>

<span class="c1">######################################################################################################################</span>

<span class="c1"># 指定sshd是否应该对远程主机名进行反向解析，以检查此主机名是否与其IP地址真实对应。默认值为&quot;yes&quot;。</span>
<span class="c1">#UseDNS no</span>

<span class="c1"># 指定在哪个文件中存放SSH守护进程的进程号，默认为 /var/run/sshd.pid 文件</span>
<span class="c1">#PidFile /var/run/sshd.pid</span>

<span class="c1"># 最大允许保持多少个未认证的连接。默认值是 10 。</span>
<span class="c1"># 到达限制后，将不再接受新连接，除非先前的连接认证成功或超出 LoginGraceTime 的限制。</span>
<span class="c1">#MaxStartups 10:30:100</span>

<span class="c1"># 是否允许 tun(4) 设备转发。可用值如下：</span>
<span class="c1"># &quot;yes&quot;, &quot;point-to-point&quot;(layer 3), &quot;ethernet&quot;(layer 2), &quot;no&quot;(默认)。</span>
<span class="c1"># &quot;yes&quot;同时蕴含着&quot;point-to-point&quot;和&quot;ethernet&quot;。</span>
<span class="c1">#PermitTunnel no</span>

<span class="c1">#ChrootDirectory none</span>
<span class="c1">#VersionAddendum none</span>

<span class="c1"># 这个特性仅能用于SSH-2，默认什么内容也不显示。&quot;none&quot;表示禁用这个特性。</span>
<span class="c1"># no default banner path</span>
<span class="c1">#Banner none</span>

<span class="c1">######################################################################################################################</span>
<span class="c1"># AcceptEnv</span>
<span class="c1"># 指定客户端发送的哪些环境变量将会被传递到会话环境中。[注意]只有SSH-2协议支持环境变量的传递。</span>
<span class="c1"># 细节可以参考/etc/ssh/ssh_config中的 SendEnv 配置指令。</span>
<span class="c1"># 指令的值是空格分隔的变量名列表(其中可以使用&#39;*&#39;和&#39;?&#39;作为通配符)。也可以使用多个 AcceptEnv 达到同样的目的。</span>
<span class="c1"># 需要注意的是，有些环境变量可能会被用于绕过禁止用户使用的环境变量。由于这个原因，该指令应当小心使用。</span>
<span class="c1"># 默认是不传递任何环境变量。</span>
<span class="c1"># Allow client to pass locale environment variables</span>
AcceptEnv LANG LC_*

<span class="c1">######################################################################################################################</span>

<span class="c1"># 系统内开启ssh服务和sftp服务都是通过/usr/sbin/sshd这个后台程序监听22端口，而sftp服务作为一个子服务，是通过/etc/ssh/sshd_config配置文件中的Subsystem实现的，如果没有配置Subsystem参数，则系统是不能sftp访问的</span>
<span class="c1"># override default of no subsystems</span>
Subsystem   sftp    /usr/lib/openssh/sftp-server

<span class="c1"># AllowGroups</span>
<span class="c1"># 这个指令后面跟着一串用空格分隔的组名列表(其中可以使用&quot;*&quot;和&quot;?&quot;通配符)。默认允许所有组登录。</span>
<span class="c1"># 如果使用了这个指令，那么将仅允许这些组中的成员登录，而拒绝其它所有组。</span>
<span class="c1"># 这里的&quot;组&quot;是指&quot;主组&quot;(primary group)，也就是/etc/passwd文件中指定的组。</span>
<span class="c1"># 这里只允许使用组的名字而不允许使用GID。相关的 allow/deny 指令按照下列顺序处理：</span>
<span class="c1"># DenyUsers, AllowUsers, DenyGroups, AllowGroups</span>
<span class="c1">#AllowGroups&lt;组名1&gt; &lt;组名2&gt; &lt;组名3&gt; ...</span>
<span class="c1">##指定允许通过远程访问的组，多个组以空格隔开。当多个用户需要通过ssh登录系统时，可将所有用户加入一个组中</span>

<span class="c1"># DenyGroups</span>
<span class="c1"># 这个指令后面跟着一串用空格分隔的组名列表(其中可以使用&quot;*&quot;和&quot;?&quot;通配符)。默认允许所有组登录。</span>
<span class="c1"># 如果使用了这个指令，那么这些组中的成员将被拒绝登录。</span>
<span class="c1"># 这里的&quot;组&quot;是指&quot;主组&quot;(primary group)，也就是/etc/passwd文件中指定的组。</span>
<span class="c1"># 这里只允许使用组的名字而不允许使用GID。相关的 allow/deny 指令按照下列顺序处理：</span>
<span class="c1"># DenyUsers, AllowUsers, DenyGroups, AllowGroups</span>
<span class="c1">#DenyGroups&lt;组名1&gt; &lt;组名2&gt; &lt;组名3&gt; ...</span>
<span class="c1">##指定禁止通过远程访问的组，多个组以空格隔开。</span>

<span class="c1">######################################################################################################################</span>

<span class="c1"># AllowUsers</span>
<span class="c1"># 这个指令后面跟着一串用空格分隔的用户名列表(其中可以使用&quot;*&quot;和&quot;?&quot;通配符)。默认允许所有用户登录</span>
<span class="c1"># 如果使用了这个指令，那么将仅允许这些用户登录，而拒绝其它所有用户。</span>
<span class="c1"># 如果指定了 USER@HOST 模式的用户，那么 USER 和 HOST 将同时被检查。# override default of no subsystems</span>
<span class="c1"># 这里只允许使用用户的名字而不允许使用UID。相关的 allow/deny 指令按照下列顺序处理：Subsystem    sftp    /usr/lib/openssh/sftp-server</span>
<span class="c1"># DenyUsers, AllowUsers, DenyGroups, AllowGroups</span>
<span class="c1">#AllowUsers&lt;用户名1&gt; &lt;用户名2&gt; &lt;用户名3&gt; ...</span>
<span class="c1">##指定允许通过远程访问的用户，多个用户以空格隔开</span>

<span class="c1"># DenyUsers</span>
<span class="c1"># 这个指令后面跟着一串用空格分隔的用户名列表(其中可以使用&quot;*&quot;和&quot;?&quot;通配符)。默认允许所有用户登录。</span>
<span class="c1"># 如果使用了这个指令，那么这些用户将被拒绝登录。</span>
<span class="c1"># 如果指定了 USER@HOST 模式的用户，那么 USER 和 HOST 将同时被检查。</span>
<span class="c1"># 这里只允许使用用户的名字而不允许使用UID。相关的 allow/deny 指令按照下列顺序处理：</span>
<span class="c1"># DenyUsers, AllowUsers, DenyGroups, AllowGroups</span>
<span class="c1">#DenyUsers&lt;用户名1&gt; &lt;用户名2&gt; &lt;用户名3&gt; ...</span>
<span class="c1">##指定禁止通过远程访问的用户，多个用户以空格隔开</span>

<span class="c1">######################################################################################################################</span>

<span class="c1"># Match</span>
<span class="c1"># 引入一个条件块。块的结尾标志是另一个 Match 指令或者文件结尾。</span>
<span class="c1"># 如果 Match 行上指定的条件都满足，那么随后的指令将覆盖全局配置中的指令。</span>
<span class="c1"># Match 的值是一个或多个&quot;条件-模式&quot;对。可用的&quot;条件&quot;是：User, Group, Host, Address 。</span>
<span class="c1"># 只有下列指令可以在 Match 块中使用：AllowTcpForwarding, Banner,</span>
<span class="c1"># ForceCommand, GatewayPorts, GSSApiAuthentication,</span>
<span class="c1"># KbdInteractiveAuthentication, KerberosAuthentication,</span>
<span class="c1"># PasswordAuthentication, PermitOpen, PermitRootLogin,</span>
<span class="c1"># RhostsRSAAuthentication, RSAAuthentication, X11DisplayOffset,</span>
<span class="c1"># X11Forwarding, X11UseLocalHost</span>

<span class="c1"># 指定TCP端口转发允许的目的地，可以使用空格分隔多个转发目标。默认允许所有转发请求。</span>
<span class="c1"># 合法的指令格式如下：</span>
<span class="c1"># PermitOpen host:port</span>
<span class="c1"># PermitOpen IPv4_addr:port</span>
<span class="c1"># PermitOpen [IPv6_addr]:port</span>
<span class="c1"># &quot;any&quot;可以用于移除所有限制并允许一切转发请求。</span>

<span class="c1"># Example of overriding settings on a per-user basis</span>
<span class="c1">#Match User anoncvs</span>
<span class="c1">#   X11Forwarding no</span>
<span class="c1">#   AllowTcpForwarding no</span>
<span class="c1">#   PermitTTY no</span>

<span class="c1">#   ForceCommand cvs server</span>
<span class="c1">#   ForceCommand</span>
<span class="c1">#   强制执行这里指定的命令而忽略客户端提供的任何命令。这个命令将使用用户的登录shell执行(shell -c)。</span>
<span class="c1">#   这可以应用于 shell 、命令、子系统的完成，通常用于 Match 块中。</span>
<span class="c1">#   这个命令最初是在客户端通过 SSH_ORIGINAL_COMMAND 环境变量来支持的</span>

PermitRootLogin yes

<span class="c1"># 指定sshd守护进程监听的端口号，默认为 22 。可以使用多条指令监听多个端口。</span>
<span class="c1"># 默认将在本机的所有网络接口上监听，但是可以通过 ListenAddress 指定只在某个特定的接口上监听。</span>
Port <span class="m">22</span>
</pre></div>

<h3 id="ssh_3">SSH端口转发<a class="headerlink" href="#ssh_3" title="Permanent link">&para;</a></h3>
<p>SSH端口转发将其他TCP端口的网络数据通过SSH链路转发，并自动加密和解密。</p>
<h3 id="_4">本地转发实例<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="c1"># 一台LDAP server，但限制远程机器连接，此时利用ssh端口转发达到从远程机器测试server的目的</span>
<span class="c1"># 命令格式：</span>
ssh -L &lt;<span class="nb">local</span> port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;
<span class="c1"># 在LDAP client执行以下命令即可建立ssh的本地端口转发</span>
ssh -L <span class="m">7001</span>:localhost:389 LDAPServer
!<span class="o">[</span>fagure<span class="o">](</span>http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/image002.jpg<span class="o">)</span>
<span class="c1"># 在选择端口号时要注意非管理员帐号是无权绑定 1-1023 端口的，所以一般是选用一个 1024-65535 之间的并且尚未使用的端口号即可</span>
<span class="c1"># 然后我们可以将远程机器（LdapClientHost）上的应用直接配置到本机的 7001 端口上（而不是 LDAP 服务器的 389 端口上）</span>
<span class="c1"># SSH 同时提供了 GatewayPorts 关键字，我们可以通过指定它与其他机器共享这个本地端口转发。</span>
ssh -g -L &lt;<span class="nb">local</span> port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;
</pre></div>

<h3 id="_5">远程转发实例<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="c1"># 假设由于网络或防火墙的原因我们不能用 SSH 直接从 LdapClientHost 连接到 LDAP 服务器（LdapServertHost），但是反向连接却是被允许的。那此时我们的选择自然就是远程端口转发了。</span>
<span class="c1"># 命令格式：</span>
ssh -R &lt;<span class="nb">local</span> port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;
<span class="c1"># 在LDAP服务器（LdapServertHost）端执行如下命令：</span>
ssh -R <span class="m">7001</span>:localhost:389 LdapClientHost
!<span class="o">[</span>figure<span class="o">](</span>http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/image003.jpg<span class="o">)</span>
</pre></div>

<h3 id="_6">多主机转发应用实例<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="c1"># 本地转发命令中的&lt;remote host&gt;和&lt;SSH hostname&gt;可以是不同的机器</span>
ssh -L &lt;<span class="nb">local</span> port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;
<span class="c1"># 看一个涉及到四台机器 (A,B,C,D) 的例子</span>
!<span class="o">[</span>figure<span class="o">](</span>http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/image004.jpg<span class="o">)</span>
<span class="c1"># 在 SSH Client(C) 执行下列命令来建立 SSH 连接以及端口转发：</span>
ssh -g -L <span class="m">7001</span>:&lt;B&gt;:389 &lt;D&gt;
<span class="c1"># 然后在我们的应用客户端（A）上配置连接机器（C ）的 7001 端口即可,在上述连接中，（A）&lt;-&gt; (C) 以及 (B)&lt;-&gt;(D) 之间的连接并不是安全连接，它们之间没有经过 SSH 的加密及解密。</span>
</pre></div>

<h3 id="_7">动态转发实例<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="c1"># 当我们在一个不安全的 WiFi 环境下上网，用 SSH 动态转发来保护我们的网页浏览及 MSN 信息无疑是十分必要的。实际是创建了一个socks代理服务</span>
<span class="c1"># 命令格式：</span>
ssh -D &lt;<span class="nb">local</span> port&gt; &lt;SSH Server&gt;
!<span class="o">[</span>figure<span class="o">](</span>http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/image005.jpg<span class="o">)</span>
<span class="c1"># 此时 SSH 所包护的范围只包括从浏览器端（SSH Client 端）到 SSH Server 端的连接，并不包含从 SSH Server 端 到目标网站的连接。如果后半截连接的安全不能得到充分的保证的话，这种方式仍不是合适的解决方案。</span>
</pre></div>

<h3 id="x">X协议转发实例<a class="headerlink" href="#x" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="c1"># 可用作远程桌面连接，被远程端是Windows可安装xming作为xserver。ssh client可以选择putty配置ssh访问并建立x-forward（转发）</span>
ssh -X &lt;SSH Server&gt;
</pre></div>

<h2 id="linux_1">linux磁盘详解<a class="headerlink" href="#linux_1" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span>磁盘分区有主分区、扩展分区、逻辑分区，一块硬盘最多可以有四个主分区，其中一个主分区的位置可以用一个扩展分区替换，且一块硬盘只能有一个扩展分区，在这个扩展分区内可以划分多个逻辑分区。
预计超过四个分区，至少一个扩展分区：
3p+1e、2p+1e、1p+1e-----p：主分区、e：扩展分区
最多只能有一个扩展分区，扩展分区不能使用，必须再扩展分区上划分多个逻辑分区，然后格式化<span class="o">(</span>格式化的主要目的是创建文件系统--存储数据的方式<span class="o">)</span>接着才能存放数据或者安装系统

磁盘分区的设备名：
再linux中，通过设备名访问设备，设备名存放在/dev目录
--系统的第一块IDE接口的硬盘名称为/dev/hda
--系统的第二块IDE接口的硬盘名称为/dev/hdb
--系统的第一块SCSI接口的硬盘名称为/dev/sda
--系统的第二块SCSI接口的硬盘名称为/dev/sdb

分区则使用数字编号标识：
--系统的第一块IDE接口的硬盘第一个分区名称为/dev/hda1
--系统的第二块IDE接口的硬盘第六个分区名称为/dev/hda6
--系统的第一块SCSI接口的硬盘第一个分区名称为/dev/sdb1
--系统的第二块SCSI接口的硬盘第一个分区名称为/dev/sdb6

注意：
分区数字编号1-4留给主分区或者扩展分区使用，逻辑分区是在扩展分区的基础上编号从5开始
SCSI/SAS/SATA/USB接口的硬盘的设备名均以/dev/sd开头，不同硬盘编号依次是/dev/sda、/dev/sdb
SAS/SATA是主流硬盘接口，SSD固态硬盘，速度性能SSD&gt;SAS&gt;SATA
</pre></div>

<h2 id="raid0-1-5-10">Raid0 1 5 10详解<a class="headerlink" href="#raid0-1-5-10" title="Permanent link">&para;</a></h2>
<p>RAID(Redundant Array of Independent Disk 独立冗余磁盘阵列)</p>
<p>A, B, C, D, E and F     代表blocks(块)
p1, p2, and p3          代表parity(奇偶校验)</p>
<p>RAID 0 （又称为Stripe或Striping－－分条）
即Data Stripping数据分条技术。RAID 0可以把多块硬盘连成一个容量更大的硬盘群，可以提高磁 盘的性能和吞吐量。RAID 0没有冗余或错误修复能力，成本低，要求至少两个磁盘，一般只是在那些对数 据安全性要求不高的情况下才被使用,并行操作使同一时间内磁盘读写速度提升</p>
<p>最少需要两块磁盘
数据条带式分布
没有冗余，性能最佳(不存储镜像、校验信息)
不能应用于对数据安全性要求高的场合
<img alt="raid 0" src="http://static.thegeekstuff.com/wp-content/uploads/2010/07/raid-0.png" /></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">容错性</td>
<td align="center">没有</td>
</tr>
<tr>
<td align="center">热备盘选项</td>
<td align="center">没有</td>
</tr>
<tr>
<td align="center">随机写性能</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">需要的磁盘数</td>
<td align="center">只需2个或2*N个（这里应该是多于两个硬盘都可以）</td>
</tr>
<tr>
<td align="center">典型应用</td>
<td align="center">无故障的迅速读写，要求安全性不高，如图形工作站等</td>
</tr>
</tbody>
</table>
<p>RAID 1 （又称为Mirror或Mirroring－－镜像）
RAID 1称为磁盘镜像：把一个磁盘的数据镜像到另一个磁盘上，在不影响性能情况下最大限度的保证系统的可靠性和可修复性上，具有很高的数据冗余能力，但磁盘利用 率为50%，故成本最高，多用在保存关键性的重要数据的场合。RAID 1的操作方式是把用户写入硬盘的数据百分之百地自动复制到另外一个硬盘上</p>
<p>最少需要2块磁盘
提供数据块冗余
性能好
<img alt="raid 1" src="http://static.thegeekstuff.com/wp-content/uploads/2010/07/raid-1.png" /></p>
<p>RAID 5 （可以理解为是RAID 0和RAID 1的折衷方案，但没有完全使用RAID 1镜像理念，而是使用了“奇偶校验信息”来作为数据恢复的方式，与下面的RAID10不同,RAID 5 是一种存储性能、数据安全和存储成本兼顾的存储解决方案</p>
<p>最少3块磁盘
数据条带形式分布
以奇偶校验作冗余
适合多读少写的情景，是性能与数据冗余最佳的折中方案
<img alt="raid 5" src="http://static.thegeekstuff.com/wp-content/uploads/2010/07/raid-5.png" /></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">容错性</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">热备盘选项</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">随机写性能</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">需要的磁盘数</td>
<td align="center">三个或更多</td>
</tr>
<tr>
<td align="center">可用容量</td>
<td align="center">（n-1）/n的总磁盘容量（n为磁盘数）</td>
</tr>
<tr>
<td align="center">典型应用</td>
<td align="center">随机数据传输要求安全性高，如金融、数据库、存储等</td>
</tr>
</tbody>
</table>
<p>RAID10也被称为镜象阵列条带。象RAID0一样，数据跨磁盘抽取；象RAID1一样，每个磁盘都有一个镜象磁盘, 所以RAID 10的另一种会说法是 RAID 0+1。RAID10提供100%的数据冗余，支持更大的卷尺寸</p>
<p>最少需要4块磁盘
先按RAID 0分成两组，再分别对两组按RAID 1方式镜像
兼顾冗余(提供镜像存储)和性能(数据条带形分布)
在实际应用中较为常用(尤其是数据库中)
<img alt="raid 10" src="http://static.thegeekstuff.com/wp-content/uploads/2010/08/raid10.png" /></p>
<p>RAID总结</p>
<table>
<thead>
<tr>
<th align="center">安全性</th>
<th align="center">磁盘利用率</th>
<th align="center">成本</th>
<th align="center">应用方面</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">最差（完全无安全保障）</td>
<td align="center">最高（100％）</td>
<td align="center">最低</td>
<td align="center">个人用户</td>
</tr>
<tr>
<td align="center">最高（提供数据的百分之百备份）</td>
<td align="center">差（50％）</td>
<td align="center">最高</td>
<td align="center">适用于存放重要数据，如服务器和数据库存储等领域。</td>
</tr>
<tr>
<td align="center">RAID 5&lt;RAID 1</td>
<td align="center">RAID 5&gt;RAID 1</td>
<td align="center">RAID 5&lt;RAID 1</td>
<td align="center">是一种存储性能、数据安全和存储成本兼顾的存储解决方案。</td>
</tr>
<tr>
<td align="center">RAID10＝RAID1</td>
<td align="center">RAID10＝RAID1（50％）</td>
<td align="center">RAID10＝RAID1</td>
<td align="center">集合了RAID0，RAID1的优点，但是空间上由于使用镜像，而不是类似RAID5的“奇偶校验信息”，磁盘利用率一样是50％</td>
</tr>
</tbody>
</table>
<h3 id="linux_2">Linux文件系统目录介绍<a class="headerlink" href="#linux_2" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>基本文件系统类型：
--普通文件：如文本文件、c语言源代码、shell脚本等，可以用cat、less、more、vi等来察看内容，用mv来改名；
--目录文件：包括文件名、子目录名及其指针，可以用ls列出目录文件；
--链接文件：是指向一索引节点的那些目录条目，用ls来查看时，链接文件的标志用l开头，而文件后以<span class="s2">&quot;-&gt;&quot;</span>指向所链接的文件；
--特殊文件：如磁盘、终端、打印机等都在文件系统中表示出来，常放在/dev目录内；
可以用file命令来识别。

.：表示当前目录，也可以用./表示；
..：表示上一级目录，也可以用../表示；
~：代表用户自己的宿主目录；

/bin       保存可执行的二进制文件（可执行的指令）权限对所有用户开放；

/boot<span class="o">(</span>分区大小：100m<span class="o">)</span>     引导启动所需要的文件都在此目录中、包含了内核文件3.7M大小，驱动，插件，模块等文件；
/boot：存放开机启动加载程序的核心文件,包括引导文件、内核文件、驱动、 插件、模块等；<span class="o">(</span>如kernel和grup<span class="o">)</span>
    config-2.6.18-164.el5：系统kernel的配置文件，内核编译完成保存的就是这个配置文件；
    lost+found：说明/boot是一个独立的ext3文件系统；
    vmlinuz-2.6.18-164.el5：系统使用kernel，非常重要；
    grub：多系统启动管理程序grub的目录，里面存放的都是grub在启时所需要的画面、配置及各阶段的配置文件；其中grub.conf是grub配置文件；
    symvers-2.6.18-164.el5.gz
    initrd-2.6.18-164.el5.img：此文件是linux系统启动时的模块应主要来源，initrd的目的就是在kernel加载系统识别cpu和内存等心信息之后，让系统进一步知道还有那些硬件是启动所必须使用的；
    System.map-2.6.18-164.el5：是系统kernel中的变量对应表；<span class="o">(</span>可以理解为是索引文件<span class="o">)</span>

/dev      存放了所有的硬件设备文件；网卡，声卡，硬盘，光驱；tty1,tty2终端，设备文件目录，虚拟文件系统，主要存放所有系统中device的相关信息，不论是使用的或未使用的设备，只要有可能使用到，就会在/dev中建立一个相对应的设备文件；设备文件分为2种类型：字符设备文件和块设备文件<span class="o">(</span>目录中基本上都是设备文件，如硬盘设备文件/dev/sda<span class="o">)</span>
 /dev/console：系统控制台，也就是直接和系统连接的监视器；
 /dev/hd：IDE设备文件；
 /dev/sd：sata、usb、scsi等设备文件；
 /dev/fd：软驱设备文件；
 /dev/tty：虚拟控制台设备文件；
 /dev/pty：提供远程虚拟控制台设备文件；
 /dev/null：所谓<span class="s2">&quot;黑洞&quot;</span>，所有写入该设备的信息都将消失，如当想将屏幕上的输出信息隐藏起来时，只要将输出信息输入到/dev/null即可；

/etc：主机、系统或网络配置文件存放目录；
    简单的将/etc目录分为以下几类：
    --基本文件：所有直接放在/etc目录下的文件归类为基本文件；
            aliases：用于设置邮件别名；
            auto.*：代表的是一系列autofs服务所需要的配置文件，这个服务主要是让管理员可以事先定义出一些网络、本机或光驱等默认的路径；
            auto.master：负责规划目录的分配与使用，目前默认提供三种自动挂载模式；
            auto.misc：文件中的配置都以实体连接本机的磁盘驱动器为主；
            auto.net：并不是一个配置文件，而是一个脚本文件，在使用上其实不须做任何调整；；
            auto.smb：与auto.net一样，都是以个脚本文件；
            bashrc：用户登录功能配置，全局配置，对所有用户生效，主要配置别名；
            profile：与系统环境配置或初始化软件的相关配置，全局配置，对所有用户生效，主要配置变量；
            DIR_COLORS：用于配置ls命令的颜色，主要针对tty登录的用户；
            DIR_COLORS.xterm：用于配置ls命令的颜色，主要针对xterm登录的用户；
            fstab：系统启动时自动挂载文件系统的配置文件；
            inittab：启动时系统所需要的第一个配置文件；也即是init进程的配置文件；
            issue：用户本机登录时，看到的欢迎信息；
            issue.net：用户网络登录时，看到的欢迎信息；
            ld.so.conf：包含ld.so.conf.d/*.conf配置；主要是ld.so.conf.d/*.conf目录的作用；
            localtime：系统所使用的时区对应的配置文件；对应的时区文件都存在于/usr/share/zoneinfo/
            motd：登录成功的用户显示的信息对应的配置文件；
            mtab：可以当做是检查当前文件系统挂载情况的配置文件；与mount命令结果一致；
            prelink.conf：定义哪些执行文件和函数库是需要预先连接的；
            securetty：主要是login程序在使用的，只要是列在该文件中的接口，就表示是可以使用的接口，相反，若从列表中删除，则无法使用该接口；
            shells：记录目前系统所拥有shell种类的路径，通过cssh命令使用；
            sudoers：sudo命令对应的配置文件，用于配置权限的分配方式；
            sysctl.conf：主要是帮助用户配置/proc/sys目录下所有文件的值，与sysctl命令对应；
            syslogd.conf：是syslogd服务的配置文件
            host.conf：主机名解析配置文件，主要说明解析的方式及顺序；
            hosts：主机名解析配置文件，主要列出所有需要本地解析的主机名与IP地址的对应关系；
            hosts.allow和hosts.deny：linux网络安全机制TCP Wrapper对应的配置文件；
            nsswitch.conf：主要记录系统应如何查询主机名、密码、用户组、网络等，或是查询顺序的编排；
            resolv.conf：记录DNS服务器地址，用于DNS域名解析；
            services：定义了网络服务的默认端口号；
            xinetd.conf：xinetd的主配置文件，目的是为xinetd.d下的所有子服务建立一个标准的规范使其可以遵循；
            anacrontab：属于一种任务计划软件的配置文件，anacrontab软件和crond其实有点相辅相成，crond负责任务计划，而anacrontab则是负责以<span class="s2">&quot;间隔多久&quot;</span>为主要的目标；
            at.deny：该文件属于拒绝列表，只要被记录在其中的用户，就无法使用at所提供的任务计划服务；
            at.allow：与at.deny刚好相反；
            crontab：crontab的主配置文件，crond默认会执行的文件可以参考此配置文件；
            cron.deny：该文件属于拒绝列表，只要被记录在其中的用户，就无法使用crond所提供的任务计划服务；
            cron.allow：与cron.deny刚好相反；
            exports：是NFS服务的主配置文件，主要目的就是将本机的目录共享到网络上，供其他人使用；
            group与gshadow：用户组配置文件，group主要保存用户组信息，gshadow主要保存群组密码；
            login.defs：设置系统在建立账号时所参考的配置；
            passwd：主要保存系统用户账号的信息；
            shadow：linux系统通常包经过<span class="s2">&quot;hash&quot;</span>处理后的密码存储在这个文件中；
            protocols：通信协议对应端口号的一个对照表，包含协议名称、协议号码、注释等；
            wgetrc：wget程序对应的配置文件，其中有quota、mail header、重传文件的预设次数、firewall和proxy等相关设置；
            init.d：RHEL中所有服务的默认启动脚本都存放在这里；这个是链接文件，链接到/etc/rc.d/init.d；
            csh.cshrc和csh.login： 用户启动c shells执行的初始化配置文件；
            printcap：linux系统中打印机设备对应的配置文件；
    --服务器目录：如samba、http、vsftpd等服务器配置相关目录；
            cups：linux下的打印机服务器，目录下存放的是打印机服务的配置文件；
            dnsmasq.d：dnsmasq是一种DNS的<span class="s2">&quot;轻薄机种&quot;</span>，转为区域或小型网络所设计，拥有比一般DNS更为方便简易的配置；
            httpd：apache网页服务器的配置文件所在目录；
            mail：Mail Server组件的主要配置目录，如sendmail；
            ntp：网络时间服务器的配置目录，其主要配置文件为/etc/ntp.conf；
            openldap：目录明显是LDAP的配置目录，软件名称为OpenLDAP；
            postfix：postfix组件所提供的主要配置文件目录；
            samba：文件共享服务samba的主要配置文件目录；
            smrsh：这是sendmail为了限制用户可使用的命令设计的程序，将原本用户所使用的/bin/sh替换为/usr/sbin/smrsh；
            snmp：简单网络管理软件的配置文件目录，存在snmpd.conf主配置文件；
            squid：这是linux下的代理服务器squid的配置文件目录，主配置文件是squid.conf；
            ssh：SSH服务的主要配置目录，主配置文件是sshd_config；
            vsftpd：vsftpd服务器的主要配置目录，主配置文件是vsftpd.conf；
            xinetd.d：xinetd是一个管理多个服务的daemon，这个目录下列出的服务都是由xinetd进程管理的，其主配置文件是/etc/xinetd.conf；
    --系统目录：如sysconfig、xen或网络配置等与系统运行相关的目录；
            blkid：此目录所存放的其实是一个块设备ID的临时文件，主要是记录系统中所有区块设备的标签名称、硬件的唯一识别码、文件系统的格式等基本信息；
            bluetooth：linux下使用蓝牙设备所需的配置文件；启动蓝牙检测的主要服务仍是/etc/rc.d/init.d/bluetooth，该程序使用的是hcid.conf配置文件；
            cron.X：cron.X的目录都是给cron软件存放其需要任务计划的文件所使用的，按任务计划时间的长短及配置特性分为cron.d、cron.daily、cron.hourly、cron.monthly、cron.weekly五个主要目录；
            dbus-1：D-BUS的主要配置目录，D-BUS也是一种IPC交流的方式；
            default：这里是存放一些系统软件默认值的目录，存放某些软件执行时的基本参数；
            firmware：这个目录所存放的东西是非常底层的信息，是CPU所需的microcode的实体文件；
            foomatic：与打印机相关的配置目录，实现打印一对多的方式，在foomatic中，可以记录多条打印机数据，让用户只在使用前先行配置所有需要使用的打印机即可；
            hal：全名Hardware Abstraction Layer，是linux一种管理硬件的机制，它会帮所有的应用程序或用户搜集所有PCI及USB等硬件信息，因此，用户可以很简单并实时地通过HAL的方式取得硬件的相关数据；
            isdn：ISDN服务的主要配置目录，里面包含可拨号的用户、电话、联机方式等；
            ld.so.conf.d：这个目录是ldconfig所使用的，更准确的说，它是由/etc/ld.so.conf文件所决定的；ldconfig命令的目的在于将系统中的一些函数库预先存放到内存中，让系统使用时可以比以往通过硬盘的读取速度来的更快，这样可以大幅提高系统性能，尤其当要重复读取时更明显；ldconfig要将哪些函数库丢到内存中，则须看/etc/ld.so.conf文件中所记录的信息；
            logrotate.d：此目录对系统管理员来说，是十分重要的一个目录，因为目录中的文件，记录了如何定期备份系统所需要备份的系统或软件日志文件及备份方式，目录是由logrotate组件所提供的，而里面所有文件是由各软件各自产生的；其主要配置文件是/etc/logrotate.conf；
            logwatch：logrotate主要是实现如何备份日志文件，这个目录就是记载如何分析日志文件并告诉用户的软件logwatch的配置目录；
            lsb-release.d：LSB是一个由很多人所执行的项目，其目的是将所有的Linux发行版定义为一些共同的标准；
            lvm：这个目录是LVM的基本配置文件，但配置或操作一般都只需要通过LVM提供的命令，而不会用到这个目录，除非要使用到很高级的配置才会更改此文件；
            makedev.d：MAKEDEV软件对应的配置文件目录，MAKEDEV主要用来产生设备文件，也就是说，在/dev目录下的文件都由这个命令产生的，此目录下的文件主要是针对设备文件的定义或属性，目录中存在的设备文件可以由MAKEDEV来创建，否则需要使用mknod命令了；
            modprobe.d：是modprobe命令的住配置目录，一般系统启动默认要加载的模块放在/etc/modprobe.conf中；
            netplug和netplug.d：这两个目录和网络接口的联机与否由直接关系，因为主要是控制联机时的接口操作；
            opt：此目录原本是定义为存放所有额外安装软件的主机配置文件，但目前并没有被使用到，此目录为空；
            pcmcia：这是PCMCIA的配置文件目录，PCMCIA是笔记本电脑不可或缺的接口，需要即插即用的方式，此接口使用较少；
            pm：由pm-utils组件所提供的目录，pm-utils是一套电源管理的工具软件，其中/usr/lib/pm-utils也是主要目录之一；
            ppp：ppp相关的配置文件都放在这个目录中；
            profile.d：这个目录存放的是系统部分的软件配置，但会按不同的shell执行不同的文件，默认所使用的bash会直接执行该目录下所有扩展名为.sh的文件；
            rc.d：主要用来定义在每一个执行阶段必须要执行哪些系统服务或程序，在目录中主要分为三个重要的部分：
                    --rc.sysinit：系统一开始启动时所遇到的第一个文件，此脚本文件记录服务启动之前所需准备的所有事情，包括启动时看到的欢迎画面；
                    --rcX.d：在rc.sysinit文件之后所要执行的，X是系统启动时的initdefault值，值为几则会转到那个目录下，并执行其中的所有文件，在此目录中，文件一律都由两个英文字母开始K和S，K代表kill，S代表Start；
                    --rc.local：系统初始化过程中最后一个执行的脚本文件，可以将需要开机启动的程序或脚本放置在这个脚本文件中，以实现自动运行的目的；
            readahead.d：是readahead程序的主要配置目录，为了加速操作系统的使用速度，readahead_early和readahead_later这两个进程在系统加载时，直接将日常所需要的一些文件，全部先放到硬盘的高速缓存中；
            redhat-lsb：都lsb-release.d目录都是由程序redhat-lsb所提供的；
            rwtab.d：这个目录是一个在启动时会去参考的目录，主要的文件在/etc/rwtab；这是一个系统初期的备份机制；
            sane.d：这是在系统下要使用扫描仪所需的配置目录，主要配置文件是sane.conf，sane为了方便用户在各式的扫描仪连接时都可以使用，因此，在这一目录中放置了很多种不同类型扫描仪的硬件信息，让系统在检测到扫描仪时可以直接使用；
            setuptool.d：这个目录是<span class="s2">&quot;setup&quot;</span>系统配置工具的主要配置目录；
            skel：用于初始化用户宿主目录的配置目录，当建立一个用户时，会把此目录下的所有文件复制一份到用户的宿主目录，作为用户的初始化配置；
            sysconfig：非常重要的系统配置文件的存放目录，里面放置了大量系统启动及运行相关的配置文件；
            sysconfig/network-scripts/ifcfg-eth0：网卡eth0对应的配置文件，设置内容包括设备名称、IP地址、广播地址、网关地址、网段、开机是否激活等参数
            udev：udev程序本身是一套设备的管理机制，udev通过sysfs的文件系统，可以正确地掌握目前系统上存在的硬件设备，以及针对每一个硬件设备做出不同的判断与执行；
            yum和yum.repos.d：这两个都是yum的配置目录，是一套在linux下可以自动帮助用户安装、更新、移除等的管理组件，可用来替代rpm包管理方式，主配置文件是/etc/yum.conf；yum是更新方式及外挂程序的配置目录，yum.repos.d是存放定期更新组件内容的信息；
    --安全性目录：如selinux或pam.d等管理系统安全性的目录；
            audit：这个目录所代表的是一种和目录名称一致的audit安全机制，主要以服务的方式协助管理员持续监控各文件被存取的情况；目录下的audit.rules文件主要是定义一些必要的监控规则；
            pam.d：此目录是Linux-PAM的所有配置文件，配合/lib/security目录中所有觉得函数库，提供Linux下的应用程序认证的机制；
            pam_pkcs11：PAM机制中的一种登录模块，可以让用户通过smart card做登录的操作；
            pki：PKI是一种公开密钥的管理方式，通过这样的管理模式，可以让所有网络传输有更多保障；
            racoon：这个目录是由ipsec-tools组件所提供的，ipsec的主要目的是让系统实现VPN的网路技术，在racoon目录的主配置文件racoon.conf中，定义在ipsec操作中所需要的加密算法种类以及其他细节的配置；
            security：与pam.d目录相辅相成，pam.d中的所有PAM的规则都要用到/lib/security下的PAM函数库，而/etc/security目录中，就是针对这些函数库，提供以配置文件的方式进行细节配置，对希望调整系统安全性部分增加了非常大的方便性；
            selinux：selinux是一个很新的安全性方案，它是一种针对各种文件、目录、设备或daemon等在linux所需使用到的安全性机制，而且其安全性的数据时直接记录在文件系统中；
            wpa_supplicant：这个目录被归类到安全性目录中，是因为其属于无线中安全认证的部分，存在wpa_supplicant.conf配置文件，用户可以在这个目录中加入已知可登陆的AP；
    --X Windows目录：如X11或gdm管理X windows启动或使用上的配置目录；
            alternatives：linux下可辨识扩展名的<span class="s2">&quot;文件类型&quot;</span>选项，可以针对同一类型的文件，选出一个默认用户所要使用的程序去执行；/etc/alternatives目录下有所有目前已经定义的程序名称，都以软链接的方式存在，里面每一个文件其实都有定义好的默认执行程序，可以使用alternatives命令查看及修改配置；
            fonts：这个目录就是fontconfig软件的最主要配置目录，其中/etc/fonts/fonts.conf就是对应的配置文件，/etc/fonts目录下的配置都是以XML的方式配置的；
            gconf：这一目录是GConf2的组件所建立的，GConf的作用就是提供GNOME下的应用程序注册的机制，有些类似于windows下的regedit；
            gdm：全名为GNOME Display Manger，也就是协助X Windows启动的管理软件，在GDM中的主配置文件是custom.conf，在X windows下可以利用gdmsetup命令对这个文件进行配置；
            gnome-vfs-2.0：GNOME VFS机制，让GNOME的系统可以知道每一种文件格式要如何开启或浏览，而所有的配置都需要有相对应的函数库；
            gtk-2.0：由gtk+组件提供的目录，主要是提供X Windows窗口的颜色、按钮或图案，包含软件选项的画面、选项的按钮、滚动轴的样式等；
            kde：KDE Desktop Manager的主要配置目录；主配置文件是kdmrc；
            NetworkManager：此目录的目的是让用户不需要做任何操作和配置，只要用户曾经登陆过无线AP，系统就可以记录下来，以后再次登陆时就可以方便的登陆<span class="p">;</span>
            pango：pango是一套协助GTK+将字体描绘出来的函数库，不论任何的字体或语言，都可以通过pango描绘出来；
            rhgb：系统在进入X Windows之前，有一个前置配置的图形接口，这个接口就是rhgb，其主要目的是让系统启动变得漂亮；
            scim：是Linux下目前很好用的输入法；
            sound：GNOME下有许多的应用软件，很多都会有其特殊的声音，这个目录中存放所有声音的命令路径；
            X11：X windows的核心配置目录；该目录下比较重要的文件有prefdm<span class="o">(</span>判断X windows使用哪一个Display Manager<span class="o">)</span>、主配置文件xorg.conf<span class="o">(</span>定了X windows所需使用的键盘、鼠标、显卡等相关硬件设备，重点是关于显卡的配置<span class="o">)</span>、xinit子目录<span class="o">(</span>里面都是一些X windows资源相关的配置<span class="o">)</span>
            xdg：X windows上的菜单画面，就是从这里出来的，所有在X windows中使用的菜单文字及分类，都可以在这个目录下做配置，其下的子目录menu，可以通过配置里面的文件自定义应用程序、系统管理、外观等菜单内容
    --其他目录：针对单一特殊软件的配置或未能按以上分类方式则放在此目录中；
            a2ps.cfg和a2ps-site.cfg：用于将一份文件格式转换为postscript的格式，在某些打印机或要将文件输出成一份标准格式的文件时，它会被用到；
            alsa：主要任务在于提供linux声音及声音的功能，并试着让其性能达到最佳化；
            ghostscript：在linux下要读取Adobe格式文件<span class="o">(</span>如pdf<span class="o">)</span>，最方便的方式就是使用ghostscript命令，这个目录主要用于设置在显示时使用哪种字体作为默认字体；
            gre.d：GRE是Mozilla注册的一种机制，目录中的配置文件gre.conf会注明所使用的Mozilla软件的路径和版本；
            iproute2：iproute2是一套非常强大的网络管理软件，iproute2提供的功能有很多种，此目录中存放一些网络的基本配置值；
            java：这个目录是由jpackage-utils软件提供的，这个目录是这个软件的主要配置目录，除此之外还有maven、jvm、jvm-common都是由jpackage-utils软件产生的，jpackage是一个专门为了提供java程序与函数库所存在的软件；
            mgetty+sendfax：主要用于使用linux架构一台fax server，可以使用mgetty.config来配置需要有关传真接收和发送的操作；
            php.d：主要存放的各软件<span class="o">(</span>如dbase、ldap、mysql等<span class="o">)</span>与php相关的配置文件；
            reader.conf.d：存放smart card配置文件的目录，由程序pcsc-lite提供，这个程序的主配置文件是/etc/reader.conf；
            dumpdates：存放dump命令的执行日期，dump命令可以对ext2/ext3文件系统进行检查备份；

/home      默认存放用户的宿主目录<span class="o">(</span>除了root用户<span class="o">)</span>
 /home/~/.bashrc：提供bash环境中所需使用的别名；
 /home/~/.bash_profile：提供bash环境所需的变量；一般先执.bashrc后，才会再执行.bash_profile；
 /home/~/.bash_history：用户历史命令文件，记录用户曾经输入的所有命令；<span class="o">(</span>默认为1000条，可以通过HISTSIZE变量更改<span class="o">)</span>
 /home/~/.bash_logout：当用户注销的同时，系统会自动执.bash_logout文件，如果管理员需要记录用户注销的一些额外记录动作或其他信息，就可以利用这个机制去完成；

/root     管理员root的宿主目录

/lib      需要共享的函数库与kernel模块，系统kernel启动所使用的函数库，或者当执行一些在/bin和/sbin中的命令时使用的函数库；

/mnt      挂载点目录；一般的自动挂在/media目录<span class="o">(</span>如磁盘分区，网络共享<span class="o">)</span>

/media：移动存储设备默认挂载点；<span class="o">(</span>如光盘<span class="o">)</span>

/opt      常用于放置大型的应用软件；数据库文件；

/proc    只存在于内存中的文件系统，保存操作系统的实时信息；内存信息，CPU信息，虚拟内存信息，电源信息；cpuinfo ,meminfo ,acpi,scsi,vmstat,uptime<span class="p">;</span>每次启动操作系统都会自动创建一个新的/porc文件，来记录系统的实时信息；并不是存放在硬盘上，而是内存镜像中的；虚拟文件系统，此目录是kernel加载后，在内存里面建立的一个虚拟目录，有专属的文件系统，主要提供系统一些实时的信息，此目录下不能建立和删除文件；<span class="o">(</span>某些文件可以修改<span class="o">)</span>
    /proc主要作用可以整理为：
    --整理系统内部的信息；
    --存放主机硬件信息；
    --调整系统执行时的参数；
    --检查及修改网络和主机的参数；
    --检查及调整系统的内存和性能；
    /proc下常用的信息文件有：
    /proc/cpuinfo：cpu的硬件信息，如类型、厂家、型号和性能等
    /proc/devices：记录所有在/dev目录中相关的设备文件分类方式
    /proc/filesystems：当前运行内核所配置的文件系统
    /proc/interrupts：可以查看每一个IRQ的编号对应到哪一个硬件备
    /proc/loadavg：系统<span class="s2">&quot;平均负载&quot;</span>，3个数据指出系统当前的工作负载
    /proc/dma：当前正在使用的DMA通道
    /proc/ioports：将目前系统上所有可看到的硬件对应到内存位置的配表的详细信息呈现出来
    /proc/kcore：系统上可以检测到的物理内存，主机内存多大，这个件就有多大
    /proc/kmsg：在系统尚未进入操作系统阶段，把加载kernel和initr的信息先记录到该文件中，后续会将日志信息写入/var/log/messag文件中
    /proc/meminfo：记录系统的内存信息
    /proc/modules：与lsmod命令查看到的模块信息完全一致
    /proc/mtrr：负责内存配置的机制
    /proc/iomem：主要用于储存配置后所有内存储存的明细信息
    /proc/partitions：这个文件可以实时呈现系统目前看到的分区
    /proc/数字目录：数字目录很多，它们代表所有目前正在系统中运行所有程序
    /proc/bus：有关该主机上现有总线的所有信息，如输入设备、PCI口、PCMCIA扩展卡及USB接口信息
    /proc/net目录：存放的都是一些网络相关的虚拟配置文件，都ASCII文件，可以查看<span class="o">(</span>与ifconfig、arp、netstat等有关<span class="o">)</span>
    /proc/scsi：保存系统上所有的scsi设备信息<span class="o">(</span>包括sata和usb设备信息<span class="o">)</span>
    /proc/sys目录：存放系统核心所使用的一些变量，根据不同性质的件而存放在不同的子目录中，可以通过/etc/sysctl.conf文件设置更改其默认值；变量时实时的变更，有很多设置很象是开关，设置后上生效；
    /proc/tty：存放有关目前可用的正在使用的tty设备的信息
    /proc/self：存放到查看/proc的程序的进程目录的符号连接，当2进程查看proc时，这将会是不同的连接；主要便于程序得到它自己的程目录；
    /proc/stat：系统的不同状态信息；
    /proc/uptime：系统启动的时间长度；
    /proc/version：系统核心版本；

/sbin    存放特权级二进制文件（特权级可执行命令）只有root用户可以执行；较危险的命令保存其中；<span class="o">(</span>多数管理命令默认只有管理员可以使用<span class="o">)</span>

/usr：安装除操作系统本身外的一些应用程序或组件，一般可以认为linux系统上安装的应用程序默认都安装在此目录中；
    /usr/bin：一般用户有机会使用到的程序，或者该软件默认就是要所有用户使用才会放在该目录中；
    /usr/sbin：一些系统有可能会用到的系统命令，与/sbin比起来，是一些较次要的文件；
    /usr/etc：自行安装或非系统主要的配置文件目录；
    /usr/games：只要是电脑游戏相关的软件，就都安装到这个目录；
    /usr/include：存放的文件都是一些系统中用户所会使用到的C语header文件，保存的都是<span class="s2">&quot;.h&quot;</span>的文件；
    /usr/kerberos：kerberos是一种安全机制，让用户可以直接使用持kerberos机制系统上的部分资源；
    /usr/lib：存放一些函数库、执行文件及连接文件，特别的是，存在这里面的文件都是不希望直接被用户或shell脚本所使用的文件，/usr/lib中有非常多的子目录，每一个软件都有其各自所需的函库；
    /usr/libexec：这个目录下的文件及文件夹应该都可以放置/usr/lib下；
    /usr/local：linux系统中安装的共享软件程序最好的方式是安装/usr/local下，按照linux标准目录结构，新建立的软件都应该放/usr/local下；
        /usr/local/bin：存放软件执行文件的目录；
        /usr/local/sbin：同样存放软件执行文件的目录，但此目录门针对系统所使用的文件；
        /usr/local/lib：软件相关的函数库；
        /usr/local/share：当文件性质不好归属时就会放在此，man册就放在这个目录下；
        /usr/local/src：所安装软件的源代码放置在此；
    /usr/share：此目录都是一些共享信息，最常被用到的就/usr/share/man这个目录，/usr/share里的信息时跨平台的；
    /usr/share/doc：放置一些系统帮助文件的地方；
    /usr/share/man：manpage的文件存放目录，也是使用man查看手册时查询的路径；
    /usr/src：主要储存内核源代码的文件；
    /usr/X11R6：存放一些X windows系统的相关文件；

/var    动态文件或数据存放目录，默认日志文件都存放在这个目录下，一般建议把此目录单独划分一个分区；
    /var/account：是linux系统下的审核机制<span class="o">(</span>psacct<span class="o">)</span>对应的目录；
    /var/cache：该目录下的文件时所有程序所产生的缓存数据，也就是当应用程序启动时，会将数据留一份在这个目录中；
    /var/empty：默认是sshd程序用到的这个目录，当建立ssh连接，ssh服务器必须使用该目录下的sshd子目录；
    /var/ftp：ftp服务器软件一般默认会将匿名登陆的用户的宿主目录；
    /var/gdm：gdm所使用的目录，里面存放一些系统当前所占用的console记录及通过gdm执行的X windows记录，只有通过gdm窗口的日志才会存放在此；
    /var/lib：该目录下存放很多与应用程序名称同名的子目录，每个子目录下都是应用执行的状态信息；
    /var/lock：每个服务一开始都会在这个目录下产生一个该服务的空文件，主要是避免服务启动冲突；
    /var/log：常用目录，专门用来存放所有日志文件的目录，里面存放很多系统、软件、用户等相关的日志信息；里面有一些文件是比较常用的；
        lastlog：记录用户最后一次登录的信息，使用lastlog命令读取；
        message：记录系统的几乎所有信息，主要包括启动信息，syslogd服务记录的信息等；
        wtmp：记录所有用户登陆及注销的信息，使用last命令读取；
        secure：记录登录系统访问数据的文件，如ssh pop3 telnet ftp等都会记录在此文件中
        /var/log/httpd/access_log：httpd访问日志
        /var/log/httpd/error_log：httpd错误日志
        btmp：记录失败的用户登录
        utmp： 纪录当前登录的每个用户
        xferlog：ftp会话日志
        boot.log：记录开机或一些服务启动时所显示的启动和关闭信息
        /var/log/maillog或/var/log/mail/*：记录邮件访问或往来的用户信息
        cron： 记录crontab例行性服务的内容
        dmesg：开机引导日志信息
        sudolog：纪录使用sudo发出的命令
        sulog： 纪录使用su命令的使用
    /var/named：bind软件实现的DNS服务器的区域数据文件都存放在这个目录下；
    /var/nis和/var/yp：都是NIS服务机制所使用的目录，nis主要记录所有网络中每一个client的连接信息；yp是linux的nis服务的日志文件存放的目录；
    /var/run：此目录中的大部分文件都记载目前系统正在执行程序的PID值，每一个文件都是以个独立的PID记录；此目录下存放一个特殊文件utmp，此文件记录目前谁在使用系统，必须使用utmpdump命令才能看到其中的内容；
    /var/spool：里面主要都是一些临时存放，随时会被用户所调用的数据；打印机、邮件、代理服务器等假脱机目录存放在该目录下；
    /var/tmp：专门为了一些应用程序在安装或执行时，需要在重启后使用的某些文件时，能将该文件暂时存放在这个目录中，完成后再行删除；
    /var/www：apache网页服务器的宿主目录；

/lost+found:存放了一些系统出错的检查结果；异常断电情况，死机；默认目录是空的,一般会使用fsck进行文件修复，而这些被修复或救回的文件，就会被放在这个目录下

/misc：自动挂载服务目录，对应autofs服务；

/srv：默认为空，主要用于存放一些软件的配置文件，某些软件可能会把配置文件默认存放在这个目录下，多数都是/etc目录下，此目录没有被具体的定义；

/temp  临时文件存放点；此目录有特殊的权限位粘滞位：1777

/tftpboot：远程启动tftpserver的根目录，这个目录只有安装了tftp-server软件后才会产生；

备注：
/sbin  /usr/sbin是root账户可以执行命令的存放路径
/bin  /usr/bin对于普通用户可以执行命令的存放路径
bin代表binnary ；sbin 代表super binnary；
/usr目录的重要性是和windows系统上的windows目录的重要性是一样的，都是核心文件存放的位置；

如果要做系统级备份的话，/etc ,/boot是必须要备份的目录；
备份分为了系统备份和用户备份两种；
</pre></div>

<h3 id="_8">添加硬盘或分区流程<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>分区指令fdisk--创建文件系统mkfs--挂载mount--写入配置文件/etc/fstab<span class="p">;</span>
检测硬盘是否被识别的命令：dmesg <span class="p">|</span> grep sdb

过程1：fdisk指令操作和查询
fdisk -l /dev/sdb查看硬盘的信息；
fdisk /dev/sdb 对硬盘进行分区操作<span class="p">;</span>
常用的分区命令：
m <span class="nb">help</span>
p print the partition table
n add a new partition
t change a partition<span class="err">&#39;</span>s system id
w write table to disk and <span class="nb">exit</span>
q quit without saving changes
默认的文件系统类型是ext4<span class="p">;</span>id <span class="m">83</span> ,system <span class="nb">type</span> linux
<span class="nv">id</span><span class="o">=</span><span class="m">82</span> /swap
<span class="nv">id</span><span class="o">=</span><span class="m">83</span> linux

过程2：格式化操作
<span class="c1">#mkfs.ext4</span>
<span class="c1">#mkfs -t ext4</span>
<span class="c1">#windows操作系统当中的文件系统是NTFS,fat32。前者支持磁盘配额和文件压缩，后者不支持；</span>
案例：mkfs.ext4 /dev/sdb1

过程3：文件系统挂载操作
mkdir /test/cisco
mount /dev/sdb7 /test/cisco
在目录/test/cisco中写入的内容存储到/dev/sdb7分区中；

过程4：写入启动自动挂载文件/etc/fatab
<span class="c1">#添加分区让系统启动时自动挂载：/etc/fstab文件；</span>
文件中的每行由六个部分组成：含义如下
<span class="m">1</span>，物理分区/卷标
<span class="m">2</span>，挂载点,
<span class="m">3</span>，文件系统,
<span class="m">4</span>，缺省设置,
<span class="m">5</span>，表示文件系统是否需要dump备份（dump是备份工具），一般设为1时表示需要，设为0时将被dump所忽略
<span class="m">6</span>，该数字用于决定在系统启动时进行磁盘检查的顺序，0不进行检查，1优先，2其次。对于根分区应设为1，其它分区设为2

/dev/sdb1                     /cisco                ext4          defaults  <span class="m">1</span>  <span class="m">2</span>
<span class="nv">LABLE</span><span class="o">=</span>network             /cisco              ext4          defaults  <span class="m">1</span>  <span class="m">2</span>

查看分区的卷标：e2lable /dev/sdb1
设置分区的卷标：e2lable /dev/sdb1 network
</pre></div>

<h3 id="linux_3">linux系统引导流程解析<a class="headerlink" href="#linux_3" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>系统引导流程：
首先，PC，server，any device ,它们的第一步都是一样的；
固件firmware <span class="o">(</span>CMOS/BIOS<span class="o">)</span>  post加电自检
对于固件的理解，是介于软件和硬件之间的软件代码，但同时烧录到硬件当中；CMOS固化在硬件中，作为固件的平台，BIOS是管理CMOS的管理界面；

接着，自举程序bootloader <span class="o">(</span>GRUB<span class="o">)</span>,载入内核；
第一步的最后要读取硬盘中的MBR，包含了BootLoader,在MBR中还包含了分区表等信息；

内核的工作，驱动硬件，启动初始进程init<span class="p">;</span>在kernel中大部分的东东都是动程序；init启动后读取inittab文件，执行缺省默认的运行级别，从而继引导过程；在linux系统中，init是第一个存在的进程，它的PID恒为一，但也必须向一个更高级的功能负责：PID为零的内核调度器，从而获得cpu时间；

关键点：对于父子进程的关系。首先，父进程中断，子进程同样会中断；如果父进程中断后，子进程没有中断，这种关系形象称之为孤儿进程，系统发现后会将孤儿进程指向父进程init<span class="p">;</span>如果父进程正常，而子进程中断的话，这样滴关系称之为僵尸进程；这两种进程在系统中不允许出现的；

备注：linux中的运行级别类似于windows 平台中的F8功能；
单用户模式（级别1）类似windos平台中F8的安全模式，区别是没有图形界面，只有命令输入；
运行级别2 和 3的区别就是2级别没有NFS功能，同时都是多用户模式；
查看当前的运行级别：runlevel
运行级别的切换：init <span class="m">0</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span>  S 或者 telinit0 <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span>

扩展：实际大家通过命令ls -l <span class="sb">`</span>which telinit<span class="sb">`</span>得知telinit名是init命令的一个软连接而已；

grep -v <span class="s2">&quot;^#&quot;</span> /etc/inittabl <span class="c1">#提取有效行，作为分析数据</span>
文件格式分析：（字段组成结构如下所示：）
id:runlevels：action:process
id 标示符,一般都是两位字母或者数字；
runlevels:指定运行级别，可以指定多个；例如::代表0-6
action:指定运行状态；
process:指定要运行的脚本或者命令；

action取值：
initdefault表示系统缺省的启动运行级别；
sysinit；系统启动时执行process中指定的命令；
wait:执行process中指定命令，并等到结束后在运行其他的命令
one:执行process中指定的命令，不需要等待结束；
ctrlaltdel:按下组合键执行process指定的命令；<span class="o">(</span>关机的操作<span class="o">)</span>


实例1：
id:5:initdefault:
id:3:initdefault:
<span class="c1">#initdefault表示系统缺省的启动运行级别；</span>

案例2：
si::sysinit:/etc/rc.d/rc.sysinit
<span class="c1">#运行状态sysinit表示系统启动时执行process中指定的指令；</span>
<span class="c1">#只要系统启动就会执行脚本/etc/rc.d/rc.sysinit（任何运行级别）</span>
<span class="c1">#脚本的主要作用：完成系统服务程序启动，设置系统时钟，加载字体，检查加载系统，生成系统启动信息日志，设置系统环境变量；</span>
我们可以将一些脚本或者命令写入/etc/rc.d/rc.sysinit中，重启后在任何启动级别中执行操作；
<span class="c1">##############</span>

先后顺序：
<span class="m">1</span>，id:3:initdefault：
<span class="m">2</span>，l3:3:wait:/etc/rc.d/rc
<span class="m">3</span>,/etc/rc.d/rc3.d
分析：
判断默认的运行级别调用/etc/rc.d/rc脚本，执行相关运行级别目录中的服务程序，完成相应运行级别的初始化配置；之后找到/etc/rc.d/rc3.d脚本，完成系统后续的引导过程，其作用是分别存放对应于运行级别的服务程序脚本的符号链接，链接到init.d目录中的相应脚本；
ls /etc/rc.d/r3.d 里面包含了两种文件很重要，一种大写S开头，另一种是大写的K开头；
sys19syslog
S  start   K  <span class="nb">kill</span>  number 表示启动的顺序，数字越小优先启动；如果数字相同，那么就会按照创建的时间；

Firmware
   <span class="p">|</span>
BootLoader
   <span class="p">|</span>
Kernel
   <span class="p">|</span>
 init
   <span class="p">|</span>
/etc/inittab
   <span class="p">|</span>
initdefault
   <span class="p">|</span>
/etc/rc.d/rc.sysinit
   <span class="p">|</span>
/etc/rc.d/rc
   <span class="p">|</span>
/etc/rc.d/rcN.d
   <span class="p">|</span>
Login<span class="o">(</span>username ,password<span class="o">)</span>

启动系统首先固件的加电自检；典型为PC中cmos/bios作用是在物层次面上检测所有的硬件是否正常工作；如果硬件正常的话，会读取硬盘的上存放物理数据的第一个位置MBR，MBR主要是存放自举程序BootLoader，在linux系统中我们大多数采用的是GRUB，GRUB的主要作用就是载入内核；载入内核后，两个作用，第一是在linux操作系统层面上是驱动硬件和启动init进程；然后读取/etc/inittab配置文件，配置文件会判断系统缺省的运行级别然后执行脚本/etc/rc.d/rc.sysinit加载基本的系统服务；接着
根据设置的缺省系统运行级别（id:3,5:initdefault:）执行/etc/rc.d/rc脚本，此脚本会判断initdefault，然后启动对应的运行级别目录下面的程序/etc/rc.d/rcN.d，最后出现登陆界面了，输入正确的用户名和密码即可登录系统继而管理服务器；

/etc/rc.d/init.d该目录下存放了各个运行级别的服务程序脚本；ls -ld /etc/rc.d/init.d <span class="p">;</span> ls -l /etc/rc.d/init.d<span class="p">;</span>
ls -ld /etc/init.d 发现此文件是/etc/rc.d/init.d的软连接；
设置自启动程序：
ls -s
chkconfig
ntsysv

实例：
chkconfig
chkconfig --list
chkconfig --list sshd
chkconfig --levels <span class="m">2345</span> sshd on

实例：
ntsysv --level 3图形界面来选择自动启动的服务级别；
扩展：
dmesg <span class="p">|</span> grep eth0 内核驱动硬件的过程中是否识别网卡信息；主要反馈的信息是在kernel中的驱动硬件过程中；在linux操作系统当中所有的日志文件都存放在/var/log目录中；

dmesg <span class="p">|</span> grep USB
</pre></div>

<h3 id="grub">GRUB配置文件讲解：<a class="headerlink" href="#grub" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>配置文件位置：/etc/grub.conf是个软连接文件；
原始文件/boot/grub/grub.conf
grep -v <span class="s2">&quot;^#&quot;</span> /boot/grub/grub.conf <span class="p">|</span> more
字段：
default定义缺省启动系统,0表示第一个，1表示第二个，以此类推；
-------------------------------------------------
timeout定义了缺省等待时间；默认5秒
-----------------------------------------------
splashimage定义了GRUB启动时的界面图片；
-----------------------------------------
hiddenmenu隐藏菜单；
--------------------------------------
title定义了菜单项名称；
----------------------------------------
root作用是设置GRUB的根设备也就是内核所在的分区
---------------------------------------------
kernel 定义了内核文件所在的位置
---------------------------------------------
initrd命令加载镜像文件以及显示镜像文件的位置；
--------------------------------------------
以上的几个字段选项是重点，加强记忆和操作；


GRUB设置密码


<span class="m">1</span>，使用GRUB自带的grub-md5-crypt命令
<span class="c1">#grub-md5-crypt</span>
passowrd:
在图形界面我可以选择复制选项进行复制，在字符终端界面上使用鼠标右键复制加密字符；
编辑/etc/grub.conf配置文件，在hiddenmenu字段下面插入关于插入位置没有严格的要求）
password --md5 加密字符（-md5表示口令是md5加密的）
在插入模式下插入加密的字符串；然后退出保持即可；


<span class="m">2</span>，第二中方式是在GRUB交互命令行界面使用md5crypt命令
<span class="c1">#grub</span>
grub&gt;md5crypt
password:
实现效果是一样的；

GRUB的系统修复：（手工修复）故意修改kernel指定的内核文件
grub&gt; cat /grub/grub.conf  为什么没有/boot原因就是grub存放在/boot分区；
grub&gt; 指定内核所在的分区 root <span class="o">(</span>hd0,0<span class="o">)</span>
grub&gt; 指定内核文件所在的位置
grub&gt; 指定镜像文件的位置
grub&gt; boot
手工修复属于命令行操作；如果有人修改了/etc/inittab中的默认启动级别的话，我们完全可以通过grub启动菜单来进行修复：在kernel行直接加入启动级别；

终极修复模式：光盘修复；
光盘引导，F5键，键入linux rescue
案例1：
尝试删除/etc/inittab，之前先做好备份；cp /etc/inittab /etc/inittab.bak
cp /etc/inittab /etc/inittab.back
rm -rf /etc/inittab

案例2：如果忘记了管理员密码，同时也忘记了GRUB的保护密码的话，我们可以使用GRUB的系统修复或者使用光盘的引导修复来解决此问题；
</pre></div>

<h3 id="linux_4">Linux软件包管理<a class="headerlink" href="#linux_4" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>软件包安装方式如下：
<span class="m">1</span>.二进制软件包管理RPM ,YUM
<span class="m">2</span>.源代码包安装
<span class="m">3</span>.脚本安装 shell or java

RPM软件包命名格式：
首先是软件名，版本号，发行号，以及硬件平台和后缀名

软件包管理指令：

<span class="m">1</span>，卸载软件包
<span class="c1">#rpm -e 软件包名称  使用--nodeps强行卸载情况属于有软件包依赖关系；</span>
<span class="m">2</span>，安装软件包
<span class="c1">#rpm -ivh 软件包全称(选项v和h分别表示显示详细信息和进度条选项)</span>
--nodeps强制安装软件包选项；

--excludedocs表示安装软件包的同时不安装帮助文档文件；
<span class="c1">#rpm -ivh --excludedocs</span>

--prefix PATH 表示将软件包安装到PATH指定的路径下；
<span class="c1">#rpm -ivh --prefix=/usr/local</span>

--test表示只对软件包安装进行测试，并不是实际安装；

实现覆盖安装软件包需要使用--replacepkgs选项；
<span class="c1">#rpm -ivh --replacepkgs 软件包全称；</span>

<span class="m">3</span>.查询软件包：
<span class="c1">#rpm -q 用于软件包是否安装在系统中；</span>
<span class="c1">#rpm -qa | grep XXX 查询系统中所有安装的软件包；</span>

<span class="m">4</span>.升级RPM软件包；
<span class="c1">#rpm -Uvh 软件包全称；</span>

案例：
<span class="m">1</span>.查询文件隶属的软件包----rpm -qf
rpm -qf /etc/services
rpm -qf /bin/ls
<span class="m">2</span>.查询软件包信息----- rpm -qi、rpm -qip<span class="o">(</span><span class="c1">#尚未安装到到系统中的软件包)</span>
rpm -qi vsftpd
rpm -qi samba
<span class="m">3</span>.查询软件包安装文件 rpm -ql、rpm -qlp
rpm -ql samba
rpm -ql vsftpd
rpm -ql sudo
<span class="m">4</span>.查询软件包帮助文件 rpm -qd
rpm -qd vsftpd
rpm -qd samba
rpm -qd sudo
rpm -qdp 软件包全称（未安装的软件包的帮助文件）
<span class="m">5</span>.查询软件包配置文件 rpm -qc
rpm -qc vsftp
rpm -qc samba

<span class="c1">###################</span>

YUM管理软件包机制：
首先，可以自动解决软件包的依赖关系，而且方便软件包的升级；<span class="o">(</span>前提是要接入互联网或者使用镜像文件生成本地YUM源<span class="o">)</span>

YUM的常用选项：
安装：yum install<span class="p">;</span> -y选项自动进行确认操作；
升级：yum update
软件包查询：yum list
软件包信息：yum info
卸载：yum remove
帮助：yum -help ,man yum
检测软件包升级:yum check-update

<span class="c1">###############</span>

源代码的安装：（源代码安装包一般都是最新版的软件包）
案例：
<span class="c1">#tar -zxvf proftpd-1.3.3d.tar.gz</span>
<span class="c1">#cd proftpd.1.3.3d</span>
./configure --prefix<span class="o">=</span>/usr/local/proftpd <span class="o">(</span>配置过程，也就是搜集系统信息，为后续的编译做准备<span class="o">)</span>指定目录管理很方面，大多数的使用习惯都是放在此目录下；
<span class="c1">#make 将源代码编译成二进制可执行文件；</span>
<span class="c1">#make install  将文件拷贝到相应的文件目录；</span>

源代码的特点：
<span class="m">1</span>，广泛的实用性； 所有的类unix系统都是支持源代码安装；
<span class="m">2</span>，比较灵活；     定制或者改变源代码；

<span class="c1">#####################</span>

脚本安装：图形模块化操作，webmin 工具<span class="p">;</span>
<span class="c1">#tar -zxvf webmin-1.530.tar.gz</span>
<span class="c1">#cd webmin-1.530</span>
<span class="c1">#more README</span>
<span class="c1">#./setup.sh</span>
URL:www.webmin.com
脚本安装软件包没有固定的格式，，主要查看README,INSTALL这两个帮助文件
</pre></div>

<h3 id="linux_">Linux_用户、组和权限<a class="headerlink" href="#linux_" title="Permanent link">&para;</a></h3>
<h4 id="r-w-x">一、权限：r, w, x<a class="headerlink" href="#r-w-x" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span><span class="m">1</span>.文件权限：
r：可读，可以使用类似cat等命令查看文件内容；
w：可写，可以编辑或删除此文件；
x: 可执行，eXacutable，可以命令提示符下当作命令提交给内核运行；
<span class="m">2</span>.目录权限：
r: 可以对此目录执行ls以列出内部的所有文件；
w: 可以在此目录创建文件；
x: 可以使用cd切换进此目录，也可以使用ls -l查看内部文件的详细信息；
<span class="m">3</span>.权限三位一体：
rwx:可读可学可执行
r--:只读
r-x:读和执行
---：无权限
<span class="m">4</span>.八进制表示：
<span class="m">0</span> <span class="m">000</span> ---：无权限
<span class="m">1</span> <span class="m">001</span> --x: 执行
<span class="m">2</span> <span class="m">010</span> -w-: 写
<span class="m">3</span> <span class="m">011</span> -wx: 写和执行
<span class="m">4</span> <span class="m">100</span> r--: 只读
<span class="m">5</span> <span class="m">101</span> r-x: 读和执行
<span class="m">6</span> <span class="m">110</span> rw-: 读写
<span class="m">7</span> <span class="m">111</span> rwx: 读写执行
例如：755：rwxr-xr-x
rw-r-----: <span class="m">640</span>
<span class="m">660</span>:rw-rw----
rwxrwxr-x:775
</pre></div>

<h4 id="_9">二、用户和用户组<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span><span class="m">1</span>.用户和组的文件路径：
用户：UID, /etc/passwd
组：GID, /etc/group
<span class="m">2</span>.影子口令：（真正口令文件路径）
用户：/etc/shadow
组：/etc/gshadow
<span class="m">3</span>.用户类别：
管理员：0
普通用户：1-65535
系统用户：1-499
一般用户：500-60000
<span class="m">4</span>.用户组类别：
管理员组：0
普通组：1-65535
系统组：1-499
一般组：500-60000
<span class="m">5</span>.用户组类别：
私有组：创建用户时，如果没有为其指定所属的组，系统会自动为其创建一个与用户名同名的组
基本组：用户的默认组
附加组，额外组：默认组以外的其它组
<span class="m">6</span>.解释/etc/passwd中7段意义：（用户名：密码：UID:GID：注释：家目录：默认SHELL）
<span class="m">1</span>）.account: 登录名
<span class="m">2</span>）.password: 密码
<span class="m">3</span>）.UID：
<span class="m">4</span>）.GID：基本组ID
<span class="m">5</span>）.comment: 注释
<span class="m">6</span>）.HOME DIR：家目录
<span class="m">7</span>）.SHELL：用户的默认shell
<span class="m">7</span>.解释/etc/group中4段意义： 组名：密码：GID:以此组为其附加组的用户列表
<span class="m">8</span>.解释/etc/shadow中8段意义：（用户名：密码：最近一次修改密码的时间：最短使用期限：最长使用期限：警告时间：非活动时间：过期时间：）
<span class="m">1</span>）.account: 登录名
<span class="m">2</span>）.encrypted password: 加密的密码，$中间的为salt
<span class="m">9</span>.加密方法：
对称加密：加密和解密使用同一个密码
公钥加密：每个密码都成对儿出现，一个为私钥<span class="o">(</span>secret key<span class="o">)</span>，一个为公钥<span class="o">(</span>public key<span class="o">)</span>
单向加密，散列加密：提取数据特征码，常用于数据完整性校验
<span class="m">1</span>、雪崩效应
<span class="m">2</span>、定长输出
MD5：Message Digest, 128位定长输出
SHA1：Secure Hash Algorithm, 160位定长输出
</pre></div>

<h4 id="linux_5">Linux用户管理<a class="headerlink" href="#linux_5" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre><span></span>用户配置文件：
用于信息文件:/etc/passwd
密码文件：/etc/shadow
用户组文件：/etc/group
用户组密码文件：/etc/gshadow

查看系统中有多少的用户数量，可以是wc -l /etc/passwd，因为每个用户在配置文件中占用了一行的位置空间；cut -d <span class="s2">&quot; : &quot;</span> -f <span class="m">1</span> /etc/passwd 这条指令也可以的；

新用户信息文件：/etc/skel
登陆信息文件：/etc/motd  登录成功后会看到提示信息（可以作为一个公告栏使用）；
修改/etc/issue文件的话，是在登录之前就可以看到；为了安全起见，防止看到操作系统的版本信息，可以修改/etc/issue文件的内容或者直接删除即可；
/etc/issue.net文件中的信息是作为telnet服务的提示信息

用户信息文件的格式：（冒号分隔字段）
<span class="m">1</span>.用户名：最好不要超过八位，不要使用数字表示；
<span class="m">2</span>.密码：这个字段没有真正的存放密码，只是密码位；在早前系统是存放密码的，现在为了安全性的要求改变了设置；
<span class="m">3</span>.UID：用户标识号；分为三类：超级用户，root，uid为0；普通用户，uid <span class="m">500</span>-60000，伪用户，uid <span class="m">1</span>-499

扩展：
什么是伪用户？
伪用户就是系统和程序操作时调用的用户，与系统和程序服务相关；
例如，bin ,daemon,shtudown ,halt等，任何linux操作系统都默认有这些伪用户，是系统自动生成的；
例如，mail,news,games, apache,ftp,mysql， sshd等，与linux系统的进程相关；
而且此类的用户不需要登录或者是无法登录系统当中，同时也可以没有相应的宿主目录；
<span class="c1">#########</span>
<span class="m">4</span>.GID缺省组标识号；每个用户至少属于一个用户组；每个用户组可以包括多个用户；同一个用户组的用户享有该组共有的权限；
<span class="m">5</span>.用户描述信息：用户全名信息，写一些针对性的用户；
<span class="m">6</span>.宿主目录：用户登录系统后的缺省目录，存放自己的一些信息；/root； /home/xxx一般用户默认目录

用户密码文件，/etc/shadow文件格式；
<span class="c1"># tail -2 /etc/shadow</span>
sabayon:!!:14495:0:99999:7:::
tony:<span class="nv">$1$po</span>/zD0<span class="nv">$4</span>HSh/Aeae/eJ6dNj1k7Oz1:14495:0:99999:7:::
字段分析：
字段1：用户帐号的名称
字段2：加密的密码字串信息
字段3：上次修改密码的时间（1970/1/1距修改时间的天数）
字段4：密码的最短有效天数，默认值为0
字段5：密码的最长有效天数，默认值为99999
字段6：提前多少天警告用户口令将过期，默认值为7
字段7：在密码过期之后多少天禁用此用户
字段8：帐号失效时间，默认值为 空
字段9：保留字段（未使用<span class="o">)</span>

扩展知识点：
关于建立用户设置密码的过程分析：密码先写入/etc/passwd文件的第二个字段，让后通过指令转到/etc/shadow文件中；
转化的命令是psconv，不过这个过程是自动完成的。回写的命令是pwunconv，执行此命令后密码会在/etc/passwd中的第二个字段X中出现且是加密的，这也说明了密码位保留的原因；

/etc/group文件格式：
组名：登陆用户所属组
组密码：一般不适用
Gid 组标识号
组内用户列表：属于改组的所有用户列表；

修改组的名称：
groupmod -n cisco webmin 将webmin改成cisco<span class="p">;</span>
groupadd -g <span class="m">199999</span> webmin  建立组的同时制定组Id <span class="p">;</span>
grep webmin /etc/group
groupdel 删除组名

groups查看用户所属组；

newgrp 组名 切换组，组密码作用：不是组成员的情况下切换到组；

useradd -D       cat /etc/default/useradd
以上两条命令都可以查看缺省的配置参数；

创建用户：useradd -u <span class="m">13333</span> -g webmin  -c <span class="s2">&quot;project tangsir&quot;</span> -e <span class="m">2014</span>-02-01 tangsir

gpasswd 设置组密码及管理组内成员；
-a 添加用户到用户组
-d 从用户组中删除用户
-A 设置用户组管理员
-r 删除用户组密码
-R 禁止用户切换为改组

案例：授权用户alice and  jack 对目录/cisco有写权限；
<span class="m">1</span>,mkdir /cisco
<span class="m">2</span>,groupadd aix
<span class="m">3</span>,usermod -G aix alice
<span class="m">4</span>,gpasswd -a jace aix
<span class="m">5</span>,chgrp aix /cisco
<span class="m">6</span>,chmod g+w /cisco
然后查看目录信息
ls -ld /cisco
grep aix /etc/group
su -alice
touch /cisco/hsrp
success！！！

pwck检测/etc/passwd文件
检测的时候出现提示信息，如果文件没有问题，那么出现的问题是伪用户的信息；
伪用户是不可以登陆系统；

备注：vipw编辑/etc/passwd 文件，与vi编辑/etc/passwd唯一不同的地方是会锁定文件，其他的用户是不可以编辑的；

查看用户信息指令：
id 查看用户Id和组信息；
finger 查看用户的详细信息；
who ,w, 查看当前登陆的用户信息；
su - tangsir <span class="p">;</span> su tangsir 切换用户的区别在于前者切换后的环境变量就是本身用户所有的变量信息，后者的环境变量是管理员的环境变量信息；在操作的时候会出现奇怪的现象；

扩展知识点：
如何限制用户通过su指令切换到root：<span class="o">(</span>多种方式<span class="o">)</span>
<span class="m">1</span>.首先查看一下su命令的属性信息 ls -l <span class="sb">`</span> which su <span class="sb">`</span>
su命令是带有setuid的权限，文件权限是555；
<span class="c1">#groupadd sugroup</span>
<span class="c1">#chmod 4550 /bin/su</span>
<span class="c1">#chgrp sugroup /bin/su</span>
设置以后只有root和sugroup组中的用户可以使用su命令切换到root
添加用户到sugroup组中
<span class="c1">#useradd alice</span>
<span class="c1">#passwd alice</span>
<span class="c1">#usermod -G sugroup alice /  passwd -a alice sugroup</span>

<span class="m">2</span>.默认情况下所有的用户都可以使用su 命令。 Root用户切换至普通用户不需要密码，普通用户切换至root需要输入root的密码，正是由于这样的可操作性，就会有用户不断的尝试密码。因此会对系统的安全构成威胁，这是我们可以通过对pam wheel模块进行限制，只要将允许使用su 命令的用户加入到wheel组中，并在“/etc/pam.d/su”文件中修改配置即可完成~
<span class="o">[</span>root@tom ~<span class="o">]</span><span class="c1"># cat /etc/pam.d/su | grep ^#</span>
<span class="c1">#%PAM-1.0</span>
<span class="c1"># Uncomment the following line to implicitly trust users in the &quot;wheel&quot; group.</span>
<span class="c1">#auth           sufficient      pam_wheel.so trust use_uid</span>
<span class="c1"># Uncomment the following line to require a user to be in the &quot;wheel&quot; group.</span>
<span class="c1">#auth           required        pam_wheel.so use_uid</span>
将最后一行注释行变成配置文件；
<span class="o">[</span>root@tom ~<span class="o">]</span><span class="c1"># grep wheel /etc/group</span>
wheel:x:10:alice,tangsir

查询密码和用户状态信息：
passwd -S alice 查看用户密码的状态信息；
passwd -d alice 清除用户的密码信息；
passwd -l alice 锁定用户或者通过编辑/etc/shadow中的密码位，在密码位前面加上两个叹号即可；
备注：MD5加密会生成255位的加密字符串，长度是固定的。由于密码位的长度不匹配了，密码无法验证，故而登陆不了系统；
passwd -uf alice 解锁用户
usermod -L alice 禁用用户
usermod -U alice 开启用户

手工添加用户的方法（尤其是数字用户，使用的正常的命令无法创建）
<span class="m">1</span>，建立群组
vim /etc/group
<span class="m">888</span>:x:530:888
<span class="m">2</span>.建立账号属性信息
vim /etc/passwd
<span class="m">888</span>:x:530:530:boss_account:/home/888:/bin/bash
<span class="m">3</span>.同步passwd于shadow --将passwd内容导入shadow文件中
<span class="c1">#pwconv</span>
<span class="m">4</span>，设置账号密码信息
passwd <span class="m">888</span>
<span class="m">5</span>,建立用户根目录
cp -r /etc/skel  /home/888
<span class="m">6</span>,修改根目录属性信息
chown -R <span class="m">888</span>:888 /home/888
这是最权威的设置方法~~~

扩展知识点：（linux密码破解工具john the ripper）
首先下载完成后上传到/tmp目录中解压
tar -xvf ripper-1.7.9.tar生成john-1.7.9目录
查看redme文件得知要浏览INTALL文件得知安装方法：
<span class="nb">cd</span> src <span class="p">;</span> make <span class="p">;</span> make linux-x86-sse2---x86架构的32位；
安装结束后新建用户名mama 密码123；将用户的用户信息和密码信息提取出来使用工具unshadow 来合成老式的用户文件（所谓的用户信息中包含密码字符串）
<span class="c1">#grep mama /etc/passwd &gt; /test/mama.passwd</span>
<span class="c1">#grep mama /etc/shadow &gt; /test/mama.shadow</span>
<span class="c1">#/tmp/john-1.7.9/run/unshadow /test/mama.passwd /test/mama.shadow &gt; /test/mama.john</span>
<span class="c1">#/tmp/john-1.7.9/run/john /test/mama.john</span>
免费软件下载地址：www.openwall.com/john
注意：运行unshadow和john工具命令是一定要在软件包安装目录中执行；

关于/etc/motd即messageoftoday（布告栏信息），每次用户登录时，/etc/motd文件的内容会显示在用户的终端。系统管理员可以在文件中编辑系统活动消息，例如：管理员通知用户系统何时进行软件或硬件的升级、何时进行系统维护等。如果shell支持中文，还可以使用中文，这样看起来更易于了解。
/etc/motd缺点是，用户登录系统如果是图形界面，这些信息就不会显示。

关于/etc/issue文件的使用方法与/etc/motd文件相差不大，它们的主要区别在于：当一个网络用户或通过串口登录系统上时，/etc/issue的文件内容显示在login提示符之前，而/etc/motd内容显示在用户成功登录系统之后。

issue 内的各代码意义表示如下所示：（管理人员可以自行添加）
/l 显示第几个终端机接口；
/m 显示硬件的等级 <span class="o">(</span>i386/i486/i586/i686...<span class="o">)</span>；
/n 显示主机的网络名称；
/o 显示 domain name；
/r 操作系统的版本 <span class="o">(</span>相当于 uname -r<span class="o">)</span>
/t 显示本地端时间的时间；
/s 操作系统的名称；
/v 操作系统的版本.
</pre></div>

<h3 id="_10">三、管理命令<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="m">1</span>.用户管理命令：useradd, userdel, usermod, passwd, chsh, chfn, finger, id, chage
<span class="m">1</span><span class="o">)</span>.useradd  <span class="o">[</span>options<span class="o">]</span>  USERNAME
-u UID
-g GID（基本组）
-G GID,...  （附加组）
-c <span class="s2">&quot;COMMENT&quot;</span>
-d /path/to/directory
-s SHELL
-m -k
-M
-r: 添加系统用户
<span class="m">2</span><span class="o">)</span>.userdel <span class="o">[</span>option<span class="o">]</span> USERNAME
-r: 同时删除用户的家目录
<span class="m">3</span><span class="o">)</span>.id：查看用户的帐号属性信息
-u
-g
-G
-n
<span class="m">4</span><span class="o">)</span>.finger: 查看用户帐号信息
finger USERNAME
<span class="m">5</span><span class="o">)</span>.usermod：修改用户帐号属性
-u UID
-g GID
-a -G GID：不使用-a选项，会覆盖此前的附加组；
-c
-d -m：
-s
-l
-L：锁定帐号
-U：解锁帐号
<span class="m">6</span><span class="o">)</span>.chsh: 修改用户的默认shell
<span class="m">7</span><span class="o">)</span>.chfn：修改注释信息
<span class="m">8</span><span class="o">)</span>.passwd：密码管理
passwd <span class="o">[</span>USERNAME<span class="o">]</span>
--stdin
-l
-u
-d: 删除用户密码
<span class="m">9</span><span class="o">)</span>.pwck：检查用户帐号完整性
<span class="m">2</span>.组管理命令：groupadd, groupdel, groupmod, gpasswd
<span class="m">1</span><span class="o">)</span>.groupadd：创建组
-g GID
-r：添加为系统组
<span class="m">2</span><span class="o">)</span>.groupmod
-g GID
-n GRPNAME
<span class="m">3</span><span class="o">)</span>.groupdel
<span class="m">4</span><span class="o">)</span>.gpasswd：为组设定密码
<span class="m">5</span><span class="o">)</span>.newgrp GRPNAME &lt;--&gt; <span class="nb">exit</span>
<span class="m">6</span><span class="o">)</span>.chage：更改密码使用时间
-d: 最近一次的修改时间
-E: 过期时间
-I：非活动时间
-m: 最短使用期限
-M: 最长使用期限
-W: 警告时间
<span class="m">3</span>.权限管理：chown, chgrp, chmod, <span class="nb">umask</span>
<span class="m">1</span><span class="o">)</span>.chown: 改变文件属主<span class="o">(</span>只有管理员可以使用此命令<span class="o">)</span>
格式：chown USERNAME file,...
chown USERNAME:GRPNAME file,...
chown USERNAME.GRPNAME file,...
-R: 修改目录及其内部文件的属主
--reference<span class="o">=</span>/path/to/somefile file,...
<span class="m">2</span><span class="o">)</span>.chgrp:改变文件属组
格式：chgrp GRPNAME file,...
-R：递归
--reference<span class="o">=</span>/path/to/somefile file,...改正和somefile文件一样的属组
<span class="m">3</span><span class="o">)</span>.chmod: 修改文件的权限
格式：chmod MODE file,...
-R:递归更改
--reference<span class="o">=</span>/path/to/somefile file,...改正和somefile文件一样的权限
<span class="m">4</span><span class="o">)</span>.修改某类用户或某些类用户权限：u,g,o,a
格式：chmod <span class="nv">用户类别</span><span class="o">=</span>MODE file,...
<span class="m">5</span><span class="o">)</span>.修改某类用户的某位或某些位权限：u,g,o,a
格式：chmod 用户类别+<span class="p">|</span>-MODE file,...
</pre></div>

<h3 id="_11">四、特殊权限<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>特殊权限也是一个三位的：s,s,t
<span class="m">1</span>.SUID: 运行某程序时，相应进程的属主是程序文件自身的属主，而不是动者；
格式：chmod u+s FILE  ，chmod u-s FILE
注意：如果FILE本身原来就有执行权限，则SUID显示为s；否则显示S；
<span class="m">2</span>.SGID: 运行某程序时，相应进程的属组是程序文件自身的属组，而不是动者所属的基本组；
格式：chmod g+s FILE  ， chmod g-s FILE
注意：如果FILE本身原来就有执行权限，则SUID显示为s；否则显示S
<span class="m">3</span>.Sticky: 在一个公共目录，每个都可以创建文件，删除自己的文件，但能删除别人的文件；
格式：chmod o+t DIR  ， chmod o-t DIR
注意：如果FILE本身原来就有执行权限，则SUID显示为t；否则显示T
五、umask：遮罩码
文件默认权限：666-umask
文件夹默认权限：777-umask
特殊权限默认为0
默认遮罩码：umask<span class="o">=</span><span class="m">0022</span>
更改遮罩码：umask <span class="m">0023</span>
注意：文件默认不能具有执行权限，如果算得的结果中有执行权限，则将权限加1
</pre></div>

<h3 id="linux_6">Linux进程管理<a class="headerlink" href="#linux_6" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>查看用户信息命令w,who<span class="p">;</span>
w命令显示的字符格式如下所示：
user，TTY,from,login, idle,jcpu,pcpu,what

load average:分别显示系统在过去的1,5,15分钟内的平均负载程序；
user:登陆用户，
tty:登陆终端，是本地登陆还是远程登陆（pts/0,1,2,3）
from：显示用户从何处登陆系统，如果显示“:0”显示代表了该用户是从Xwindows下，打开文本模式窗口登陆的；
idle:用户闲置的时间，这是一个计时器，一旦用户执行任何操作，该计时器便会被重置；
jcpu：以终端代号来区分，该终端所有相关的进程执行时，所消耗的CPU时间会显示在这里；
pcpu:CPU执行程序耗费的时间；
what：用户正在执行的操作；

进程的优先级（priority）：nice , renice
首先，执行程序的优先级,
格式：nice -n <span class="nb">command</span>
例如：nice --5 /etc/rc.d/init.d/vsftpd start
其次是改变正在运行中的进程的优先级
格式：renice n pid
例如：renice -20 pid
<span class="c1">#优先级的取值范围（-20,19）即使指定优先级为-30,最终的优先级还是-20，数值越小，优先级越大；因此-20的优先级是最大的；</span>

nohup命令使进程在用户退出登录后仍旧继续执行，nohup命令执行后的数据和错误信息默认存储到文件nohup.out中
格式：nohup program <span class="p">&amp;</span>
实例：nohup find /test -name cisco* &gt; /tmp/find.cisco.20130508 <span class="p">&amp;</span>

进程的终止和挂起；
ctrl+z, ctrl+c分别表示挂起和终止；
查看后台或者挂起的命令jobs
进程的恢复：
fg恢复进程到前台继续运行
bg恢复进程到后台继续运行

<span class="c1">#计划任务</span>

计划任务是linux系统管理当中非常重要的一个环节，一定要理解深刻，灵活运用；涉及到的命令如下：
at#安排作业在某一时刻执行一次；
batch#安排作业在系统负载不重时执行一次；#与at命令不同的是batch命令要检测系统的负载情况；
cron#安排周期性运行的作业；

一次性计划任务：at,batch
at的命令格式及参数；
at 【-f 文件名】 时间
at -d or atrm 删除队列中的任务
at -l or atq 查看队列中的任务

指定时间的方式分为绝对计时方法和相对计时方法；
hh:mm:today
hh:mm:tomorrow
hh:mm:星期
hh:mm:MM/DD/YY<span class="p">;</span>MMDDYY<span class="p">;</span>DD.MM.YY

now +n minutes
now +n hours
now +n days

ps -le <span class="p">|</span> grep atd
/etc/rc.d/init.d/atd start

实例：指定今天下午17:30执行某命令；此时为下午14:30,2013.5.8
多个书写方式：（仅供参考学习）
at <span class="m">5</span>:30pm
at <span class="m">17</span>:30
at <span class="m">17</span>:30 today
at now +3 hours
at now +180 minutes
at <span class="m">17</span>:30 <span class="m">05</span>.08.13
at <span class="m">17</span>:30 <span class="m">05</span>/08/13
使用ctrl+d提交任务；
<span class="c1">#以上是绝对时间和相对时间的所有格式组合；</span>
<span class="c1">#缺省情况下书写的计划任务都存放在/var/spool/目录中</span>
/var/spool/at

AT配置文件
配置文件的作用：限制那些用户可以使用AT命令
<span class="c1">#/etc/at.allow</span>
<span class="c1">#/etc/at.deny</span>
<span class="m">1</span>.如果/etc/at.allow文件存在，那么只有列在此文件中的用户才可以使用at命令；

<span class="m">2</span>.若/etc/at.allow文件不存在，则检查/etc/at.deny文件是否存在；若/etc/at.deny文件存在，则在此文件中的用户都不能使用at命令。

<span class="m">3</span>.如果两个文件都不存在，只有超级用户root可以使用at命令；

<span class="m">4</span>.如果两个文件都存在而且均为空，则所有用户都可以使用at命令；
<span class="c1">###################</span>

crontab指令
作用：用于生成cron进程所需要的crontab文件,保存的位置/var/spool/cron
cat /var/spool/cron/root
配置文件:/etc/crontab

指令用法：
crontab -l -r -e
-l 显示当前的crontab
-r 删除当前的crontab
-e 使用编辑器编辑当前的crontab文件

分，时，日，月，周   命令/脚本
原则：把知道的具体时间添上，不知道的都添上*
注意：并不是所有的计划任务一条规则就可以搞定的，
例如；要实现周一到周五的17:30发送关机广播信息，主要保存文件，然后17:45即刻关机
案例：
<span class="m">30</span> <span class="m">17</span> * * <span class="m">1</span>-5 /usr/bin/wall &lt; /etc/issue.mes
<span class="m">45</span> <span class="m">17</span> * * <span class="m">1</span>-5 /sbin/shutdown -h now
</pre></div>

<h3 id="linux5">linux上进程有5种状态<a class="headerlink" href="#linux5" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="m">1</span>. R 运行 runnable <span class="o">(</span>on run queue<span class="o">)</span><span class="c1">#运行(正在运行或在运行队列中等待)</span>
<span class="m">2</span>. S 中断 sleeping#中断<span class="o">(</span>休眠中, 受阻, 在等待某个条件的形成或接受到信号<span class="o">)</span>
<span class="m">3</span>. D 不可中断 uninterruptible sleep <span class="o">(</span>usually IO<span class="o">)</span><span class="c1">#不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</span>
<span class="m">4</span>. Z 僵死 a defunct <span class="o">(</span>”zombie”<span class="o">)</span> process#僵死<span class="o">(</span>进程已终止, 但进程描述符存在, 直到父进程调用wait4<span class="o">()</span>系统调用后释放<span class="o">)</span>
<span class="m">5</span>. T 停止 traced or stopped#停止<span class="o">(</span>进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行<span class="o">)</span>
</pre></div>

<h2 id="shell">shell脚本笔记<a class="headerlink" href="#shell" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><span class="c1"># 删除0字节文件</span>
find -type f -size <span class="m">0</span> -exec rm -rf <span class="o">{}</span> <span class="se">\;</span>

<span class="c1"># 查看进程</span>
按内存从大到小排列
ps -e  -o <span class="s2">&quot;%C  : %p : %z : %a&quot;</span><span class="p">|</span>sort -k5 -nr

<span class="c1"># 按cpu利用率从大到小排列</span>
ps -e  -o <span class="s2">&quot;%C  : %p : %z : %a&quot;</span><span class="p">|</span>sort  -nr

<span class="c1"># 打印cache里的URL</span>
grep -r -a  jpg /data/cache/* <span class="p">|</span> strings <span class="p">|</span> grep <span class="s2">&quot;http:&quot;</span> <span class="p">|</span> awk -F<span class="s1">&#39;http:&#39;</span> <span class="s1">&#39;{print &quot;http:&quot;$2;}&#39;</span>

<span class="c1"># 查看http的并发请求数及其TCP连接状态：</span>
netstat -n <span class="p">|</span> awk <span class="s1">&#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</span>

<span class="c1"># sed在这个文里Root的一行，匹配Root一行，将no替换成yes.</span>
sed -i <span class="s1">&#39;/Root/s/no/yes/&#39;</span> /etc/ssh/sshd_config

<span class="c1"># 如何杀掉mysql进程：</span>
ps aux<span class="p">|</span>grep mysql<span class="p">|</span>grep -v grep<span class="p">|</span>awk <span class="s1">&#39;{print $2}&#39;</span><span class="p">|</span>xargs <span class="nb">kill</span> -9
<span class="o">(</span>从中了解到awk的用途<span class="o">)</span>
pgrep mysql <span class="p">|</span>xargs <span class="nb">kill</span> -9

killall -TERM mysqld
<span class="nb">kill</span> -9 <span class="sb">`</span>cat /usr/local/apache2/logs/httpd.pid<span class="sb">`</span>
试试查杀进程PID

<span class="c1"># 显示运行3级别开启的服务:</span>
ls /etc/rc3.d/S* <span class="p">|</span>cut -c <span class="m">15</span>-
<span class="o">(</span>从中了解到cut的用途，截取数据<span class="o">)</span>

<span class="c1"># 如何在编写SHELL显示多个信息，用EOF</span>
cat <span class="s">&lt;&lt;EOF   ##开始</span>
<span class="s">+--------------------------------------------------------------+</span>
<span class="s">|         === Welcome to Tunoff services ===                   |</span>
<span class="s">+--------------------------------------------------------------+</span>
<span class="s">EOF</span>
<span class="c1">##结束</span>

<span class="c1"># for 的巧用(如给mysql建软链接)</span>
<span class="nb">cd</span> /usr/local/mysql/bin
<span class="k">for</span> i in *
<span class="k">do</span> ln /usr/local/mysql/bin/<span class="nv">$i</span> /usr/bin/<span class="nv">$i</span>
<span class="k">done</span>

<span class="c1"># 取IP地址：</span>
ifconfig eth0<span class="p">|</span>sed -n <span class="s1">&#39;2p&#39;</span><span class="p">|</span>awk <span class="s1">&#39;{print $2}&#39;</span><span class="p">|</span>cut -c <span class="m">6</span>-30
或者:
ifconfig eth0 <span class="p">|</span>grep <span class="s2">&quot;inet addr:&quot;</span> <span class="p">|</span>awk <span class="s1">&#39;{print $2}&#39;</span><span class="p">|</span>cut -c <span class="m">6</span>-
或者
ifconfig  <span class="p">|</span> grep <span class="s1">&#39;inet addr:&#39;</span><span class="p">|</span> grep -v <span class="s1">&#39;127.0.0.1&#39;</span> <span class="p">|</span> cut -d: -f2 <span class="p">|</span> awk <span class="s1">&#39;{ print $1}&#39;</span>
或者：
ifconfig eth0 <span class="p">|</span> sed -n <span class="s1">&#39;/inet /{s/.*addr://;s/ .*//;p}&#39;</span>
Perl实现获取IP的方法:
ifconfig -a <span class="p">|</span> perl -ne <span class="s1">&#39;if ( m/^\s*inet (?:addr:)?([\d.]+).*?cast/ ) { print qq($1\n); exit 0; }&#39;</span>

<span class="c1"># 内存的大小:</span>
free -m <span class="p">|</span>grep <span class="s2">&quot;Mem&quot;</span> <span class="p">|</span> awk <span class="s1">&#39;{print $2}&#39;</span>

<span class="c1"># 查看连接某服务端口最多的的IP地址</span>
netstat -an -t <span class="p">|</span> grep <span class="s2">&quot;:80&quot;</span> <span class="p">|</span> grep ESTABLISHED <span class="p">|</span> awk <span class="s1">&#39;{printf &quot;%s %s\n&quot;,$5,$6}&#39;</span> <span class="p">|</span> sort

<span class="c1"># 查看Apache的并发请求数及其TCP连接状态：</span>
netstat -n <span class="p">|</span> awk <span class="s1">&#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</span>

<span class="c1"># 因为同事要统计一下服务器下面所有的jpg的文件的大小,写了个shell给他来统计.原来用xargs实现,但他一次处理一部分,搞的有多个总和....,下面的命令就能解决啦.</span>
find / -name *.jpg -exec wc -c <span class="o">{}</span> <span class="se">\;</span><span class="p">|</span>awk <span class="s1">&#39;{print $1}&#39;</span><span class="p">|</span>awk <span class="s1">&#39;{a+=$1}END{print a}&#39;</span>
CPU的数量（多核算多个CPU，
cat /proc/cpuinfo <span class="p">|</span>grep -c processor
）越多，系统负载越低，每秒能处理的请求数也越多。

<span class="c1"># CPU负载</span>
cat /proc/loadavg
检查前三个输出值是否超过了系统逻辑CPU的4倍。

mpstat <span class="m">1</span> <span class="m">1</span>
检查%idle是否过低<span class="o">(</span>比如小于5%<span class="o">)</span>

<span class="c1"># 内存空间 # free</span>
检查free值是否过低  也可以用
cat /proc/meminfo

<span class="c1"># swap空间  # free</span>
检查swap used值是否过高  如果swap used值过高，进一步检查swap动作是否频繁：
vmstat <span class="m">1</span> <span class="m">5</span>
观察si和so值是否较大

<span class="c1"># 磁盘空间  # df -h</span>
检查是否有分区使用率<span class="o">(</span>Use%<span class="o">)</span>过高<span class="o">(</span>比如超过90%<span class="o">)</span>  如发现某个分区空间接近用尽，可以进入该分区的挂载点，用以下命令找出占用空间最多的文件或目录：
du -cks * <span class="p">|</span> sort -rn <span class="p">|</span> head -n <span class="m">10</span>

<span class="c1"># 磁盘I/O负载  # iostat -x 1 2</span>
检查I/O使用率<span class="o">(</span>%util<span class="o">)</span>是否超过100%

<span class="c1"># 网络负载  # sar -n DEV</span>
检查网络流量<span class="o">(</span>rxbyt/s, txbyt/s<span class="o">)</span>是否过高

<span class="c1"># 网络错误  # netstat -i</span>
检查是否有网络错误<span class="o">(</span>drop fifo colls carrier<span class="o">)</span>  也可以用命令：
cat /proc/net/dev

<span class="c1"># 网络连接数目</span>
netstat -an <span class="p">|</span> grep -E “^<span class="o">(</span>tcp<span class="o">)</span>” <span class="p">|</span> cut -c <span class="m">68</span>- <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> sort -n

<span class="c1"># 进程总数  # ps aux | wc -l</span>
检查进程个数是否正常 <span class="o">(</span>比如超过250<span class="o">)</span>

<span class="c1"># 可运行进程数目</span>
列给出的是可运行进程的数目，检查其是否超过系统逻辑CPU的4倍

<span class="c1"># 用户</span>
who <span class="p">|</span> wc -l
检查登录用户是否过多 <span class="o">(</span>比如超过50个<span class="o">)</span>
也可以用命令：uptime

<span class="c1"># 系统日志</span>
cat /var/log/rflogview/*errors
检查是否有异常错误记录  也可以搜寻一些异常关键字，例如：
grep -i error /var/log/messages
grep -i fail /var/log/messages
egrep -i <span class="s1">&#39;error|warn&#39;</span> /var/log/messages 查看系统异常

<span class="c1"># 打开文件数目</span>
lsof <span class="p">|</span> wc -l
检查打开文件总数是否过多

<span class="c1"># 杀掉80端口相关的进程</span>
lsof -i :80<span class="p">|</span>grep -v <span class="s2">&quot;PID&quot;</span><span class="p">|</span>awk <span class="s1">&#39;{print &quot;kill -9&quot;,$2}&#39;</span><span class="p">|</span>sh

<span class="c1"># 清除僵死进程。</span>
ps -eal <span class="p">|</span> awk <span class="s1">&#39;{ if ($2 == &quot;Z&quot;) {print $4}}&#39;</span> <span class="p">|</span> <span class="nb">kill</span> -9

<span class="c1"># tcpdump 抓包 ，用来防止80端口被人攻击时可以分析数据</span>
tcpdump -c <span class="m">10000</span> -i eth0 -n dst port <span class="m">80</span> &gt; /root/pkts

<span class="c1"># 然后检查IP的重复数 并从小到大排序 注意 &quot;-t\ +0&quot;  中间是两个空格</span>
less pkts <span class="p">|</span> awk <span class="o">{</span><span class="s1">&#39;printf $3&quot;\n&quot;&#39;</span><span class="o">}</span> <span class="p">|</span> cut -d. -f <span class="m">1</span>-4 <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> awk <span class="o">{</span><span class="s1">&#39;printf $1&quot; &quot;$2&quot;\n&quot;&#39;</span><span class="o">}</span> <span class="p">|</span> sort -n -t<span class="se">\ </span>+0

<span class="c1"># 查看有多少个活动的php-cgi进程</span>
netstat -anp <span class="p">|</span> grep php-cgi <span class="p">|</span> grep ^tcp <span class="p">|</span> wc -l

<span class="c1"># 利用iptables对应简单攻击</span>
netstat -an <span class="p">|</span> grep -v LISTEN <span class="p">|</span> awk ‘<span class="o">{</span>print <span class="nv">$5</span><span class="o">}</span>’ <span class="p">|</span>grep -v <span class="m">127</span>.0.0.1<span class="p">|</span>grep -v 本机ip<span class="p">|</span>sed  “s/::ffff://g”<span class="p">|</span>awk ‘BEGIN <span class="o">{</span> <span class="nv">FS</span><span class="o">=</span>”:” <span class="o">}</span> <span class="o">{</span> Num<span class="o">[</span><span class="nv">$1</span><span class="o">]</span>++ <span class="o">}</span> END <span class="o">{</span> <span class="k">for</span><span class="o">(</span>i in Num<span class="o">)</span> <span class="k">if</span><span class="o">(</span>Num&gt;8<span class="o">)</span> <span class="o">{</span> print i<span class="o">}</span> <span class="o">}</span>’ <span class="p">|</span>grep ‘<span class="o">[</span><span class="m">0</span>-9<span class="o">]</span><span class="se">\{</span><span class="m">1</span>,3<span class="se">\}\.</span><span class="o">[</span><span class="m">0</span>-9<span class="o">]</span><span class="se">\{</span><span class="m">1</span>,3<span class="se">\}\.</span><span class="o">[</span><span class="m">0</span>-9<span class="o">]</span><span class="se">\{</span><span class="m">1</span>,3<span class="se">\}\.</span><span class="o">[</span><span class="m">0</span>-9<span class="o">]</span><span class="se">\{</span><span class="m">1</span>,3<span class="se">\}</span>’<span class="p">|</span>  xargs -i<span class="o">[]</span> iptables -I INPUT -s <span class="o">[]</span> -j DROP
Num&gt;8部分设定值为阀值，这条句子会自动将netstat -an 中查到的来自同一ip的超过一定量的连接的列入禁止范围。   基中本机ip改成你的服务器的ip地址

<span class="c1"># 怎样知道某个进程在哪个CPU上运行？</span>
ps -eo pid,args,psr

<span class="c1"># 查看硬件制造商</span>
dmidecode -s system-product-name

<span class="c1"># perl如何编译成字节码，这样在处理复杂项目的时候会更快一点？</span>
perlcc -B -o webseek webseek.pl

<span class="c1"># 统计var目录下文件以M为大小,以列表形式列出来。</span>
find /var -type f <span class="p">|</span> xargs ls -s <span class="p">|</span> sort -rn <span class="p">|</span> awk <span class="s1">&#39;{size=$1/1024; printf(&quot;%dMb %s\n&quot;, size,$2);}&#39;</span> <span class="p">|</span> head

<span class="c1"># 查找var目录下文件大于100M的文件，并统计文件的个数</span>
find /var -size +100M -type f <span class="p">|</span> tee file_list <span class="p">|</span> wc -l

<span class="c1"># sed 查找并替换内容</span>
sed -i <span class="s2">&quot;s/varnish/LTCache/g&quot;</span> <span class="sb">`</span>grep <span class="s2">&quot;Via&quot;</span> -rl /usr/local/src/varnish-2.0.4<span class="sb">`</span>
sed -i <span class="s2">&quot;s/X-Varnish/X-LTCache/g&quot;</span> <span class="sb">`</span>grep <span class="s2">&quot;X-Varnish&quot;</span> -rl /usr/local/src/varnish-2.0.4<span class="sb">`</span>

<span class="c1"># 查看服务器制造商</span>
dmidecode -s system-product-name

<span class="c1"># wget 模拟user-agent抓取网页</span>
wget -m -e <span class="nv">robots</span><span class="o">=</span>off -U <span class="s2">&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6&quot;</span> http://www.example.com/

<span class="c1"># 统计目录下文件的大小（按M打印显示）</span>
du <span class="nv">$1</span> --max-depth<span class="o">=</span><span class="m">1</span> <span class="p">|</span> sort -n<span class="p">|</span>awk <span class="s1">&#39;{printf &quot;%7.2fM ----&gt; %s\n&quot;,$1/1024,$2}&#39;</span><span class="p">|</span>sed <span class="s1">&#39;s:/.*/\([^/]\{1,\}\)$:\1:g&#39;</span>

<span class="c1"># 关于CND实施几个相关的统计</span>
统计一个目录中的目录个数
ls -l <span class="p">|</span> awk <span class="s1">&#39;/^d/&#39;</span> <span class="p">|</span> wc -l
统计一个目录中的文件个数
ls -l <span class="p">|</span> awk <span class="s1">&#39;/^-/&#39;</span> <span class="p">|</span> wc -l
统计一个目录中的全部文件数
find ./ -type f -print <span class="p">|</span> wc -l
统计一个目录中的全部子目录数
find ./ -type d -print <span class="p">|</span> wc -l
统计某类文件的大小:
find ./ -name <span class="s2">&quot;*.jpg&quot;</span> -exec wc -c <span class="o">{}</span> <span class="se">\;</span><span class="p">|</span>awk <span class="s1">&#39;{print $1}&#39;</span><span class="p">|</span>awk <span class="s1">&#39;{a+=$1}END{print a}&#39;</span>

<span class="c1"># 查找占用磁盘IO最多的进程</span>
wget -c http://linux.web.psi.ch/dist/scientific/5/gfa/all/dstat-0.6.7-1.rf.noarch.rpm
dstat -M topio -d -M topbio

<span class="c1"># 去掉第一列（如行号代码）</span>
awk <span class="s1">&#39;{for(i=2;i&lt;=NF;i++) if(i!=NF){printf $i&quot; &quot;}else{print $i} }&#39;</span> list

<span class="c1"># 输出256中色彩</span>
<span class="k">for</span>
i in <span class="o">{</span><span class="m">0</span>..255<span class="o">}</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> -e <span class="s2">&quot;\e[38;05;</span><span class="si">${</span><span class="nv">i</span><span class="si">}</span><span class="s2">m</span><span class="si">${</span><span class="nv">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">;</span> <span class="k">done</span> <span class="p">|</span> column -c <span class="m">80</span> -s <span class="s1">&#39; &#39;</span><span class="p">;</span> <span class="nb">echo</span> -e <span class="s2">&quot;\e[m&quot;</span>

<span class="c1"># 查看机器支持内存</span>
机器插内存情况：
dmidecode <span class="p">|</span>grep -P <span class="s2">&quot;Maximum\s+Capacity&quot;</span>
机器最大支持内存：
dmidecode <span class="p">|</span>grep -P <span class="s2">&quot;Maximum\s+Capacity&quot;</span>

<span class="c1"># 查看PHP-CGI占用的内存总数：</span>
<span class="nv">total</span><span class="o">=</span><span class="m">0</span><span class="p">;</span> <span class="k">for</span> i in <span class="sb">`</span>ps -C php-cgi -o <span class="nv">rss</span><span class="o">=</span><span class="sb">`</span><span class="p">;</span> <span class="k">do</span> <span class="nv">total</span><span class="o">=</span><span class="k">$((</span><span class="nv">$total</span><span class="o">+</span><span class="nv">$i</span><span class="k">))</span><span class="p">;</span> <span class="k">done</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">&quot;PHP-CGI Memory usage: </span><span class="nv">$total</span><span class="s2"> kb&quot;</span>
如果希望在成功地执行一个命令之后再执行另一个命令，或者在一个命令失败后再执行另一个命令，<span class="o">&amp;&amp;</span>和<span class="o">||</span>可以完成这样的功能。相应的命令可以是系统命令或shell脚本。
Shell还提供了在当前shell或子shell中执行一组命令的方法，即使用（）和<span class="o">{}</span>

<span class="c1"># 杀掉hello这个进程，使用下面这个命令就能直接实现。</span>
ps -ef <span class="p">|</span>grep hello <span class="p">|</span>awk <span class="s1">&#39;{print $2}&#39;</span><span class="p">|</span>xargs <span class="nb">kill</span> -9

<span class="c1"># 使用&amp;&amp;</span>
使用<span class="o">&amp;&amp;</span>的一般形式为：
命令1 <span class="o">&amp;&amp;</span> 命令2
这种命令执行方式相当地直接。<span class="o">&amp;&amp;</span>左边的命令（命令1）返回真<span class="o">(</span>即返回0，成功被执行）后，<span class="o">&amp;&amp;</span>右边的命令（命令2）才能够被执行；换句话说，“如果这个命令执行成功<span class="o">&amp;&amp;</span>那么执行这个命令”。
这里有一个使用<span class="o">&amp;&amp;</span>的简单例子：
cp justing.doc justing.bak  <span class="o">&amp;&amp;</span> <span class="nb">echo</span> “if you are seeing this <span class="k">then</span> cp was OK”
<span class="k">if</span> you are seeing this <span class="k">then</span> cp  was OK
在上面的例子中，<span class="o">&amp;&amp;</span>前面的拷贝命令执行成功，所以<span class="o">&amp;&amp;</span>后面的命令（echo命令）被执行。
再看一个更为实用的例子：
mv /apps/bin /apps/dev/bin  <span class="o">&amp;&amp;</span> rm -r /apps/bin
在上面的例子中，/apps/bin目录将会被移到/apps/dev/bin目录下，如果它没有被成功执行，就不会删除/apps/bin目录。
在下面的例子中，文件quarter_end.txt首先将被排序并输出到文件quarter.sorted中，只有这一命令执行成功之后，文件quarter.sorted才会被打印出来：
sort quarter_end.txt &gt;  quarter.sorted <span class="o">&amp;&amp;</span> lp quarter.sorted
</pre></div>

<h3 id="_12">杀死进程命令例子<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>pgrep firefox <span class="p">|</span> xargs <span class="nb">kill</span> -s <span class="m">9</span>
<span class="nb">kill</span> -s <span class="m">9</span> <span class="sb">`</span>pgrep firefox<span class="sb">`</span>
pkill -9 firefox
killall -9 firefox（完整进程名称）
</pre></div>

<h3 id="_13">统计并杀死僵尸进程例子<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>统计僵尸进程数目
ps -ef <span class="p">|</span> grep defunct <span class="p">|</span> grep -v grep <span class="p">|</span> wc -l
或
ps -eo ppid,stat <span class="p">|</span> grep Z <span class="p">|</span> wc -l

杀死僵尸进程
ps -eo ppid,stat <span class="p">|</span> grep Z <span class="p">|</span> cut -d” ” -f2 <span class="p">|</span> xargs <span class="nb">kill</span> -9
或
<span class="nb">kill</span> -HUP <span class="sb">`</span>ps -A -ostat,ppid <span class="p">|</span> grep -e ’^<span class="o">[</span>Zz<span class="o">]</span>‘ <span class="p">|</span> awk ’<span class="o">{</span>print <span class="nv">$2</span><span class="o">}</span>’<span class="sb">`</span>
或
ps -A -ostat,ppid <span class="p">|</span> awk <span class="s1">&#39;/[zZ]/{print $2}&#39;</span>
或
<span class="nb">kill</span> <span class="k">$(</span>ps -A -ostat,ppid <span class="p">|</span> awk <span class="s1">&#39;/[zZ]/{print $2}&#39;</span> <span class="p">|</span> sort -u<span class="k">)</span>
</pre></div>

<h3 id="rss">进程按rss排序<a class="headerlink" href="#rss" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>ps p <span class="m">22763</span>  -L -o pcpu,pid,tid,time,tname,cmd,pmem,rss --sort rss
</pre></div>

<h3 id="1pcputid">进程按第1列pcpu排序、tid为线程号<a class="headerlink" href="#1pcputid" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>ps p <span class="m">26653</span> -L -o pcpu,tid <span class="p">|</span>sort -k1 -r -n<span class="p">|</span>less
</pre></div>

<h3 id="_14">按进程消耗内存多少排序<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>ps -eo rss,pmem,pcpu,vsize,args <span class="p">|</span> sort -k <span class="m">1</span> -r -n <span class="p">|</span> less

命令解释：
ps是linux,unix显示进程信息的, -e 是显示所有进程, -o是定制显示信息的格式

rss: resident <span class="nb">set</span> size, 表示进程占用RAM<span class="o">(</span>内存<span class="o">)</span>的大小，单位是KB

pmem: %M, 占用内存的百分比

pcpu：%C，占用cpu的百分比

vsize:表示进程占用的虚拟内存的大小，KB

args：进程名<span class="o">(</span><span class="nb">command</span><span class="o">)</span>

sort命令对ps结果进行排序

-k1 :按第一个参数 rss进行排序

-r：逆序

-n：numeric，按数字来排序
</pre></div>

<p>ps -mp pid -o THREAD,tid,time
其次将需要的线程ID转换为16进制格式：
printf "%x\n" tid
打印线程的堆栈信息：
jstack pid |grep tid -A 30</p>
<div class="codehilite"><pre><span></span>由于ps的输出是按PID号的顺序显示的，若要实现按照某一项使用量排序，需要把某项放入最前面。

<span class="o">(</span>按照内存使用量从大到小排序<span class="o">)</span>
ps -auxww<span class="p">|</span>awk <span class="s1">&#39;{print $5,$1,$11}&#39;</span><span class="p">|</span>sort -r<span class="p">|</span>more

按虚拟内存从大到小排列进程:
ps -eo <span class="s2">&quot;%C%p%z%a&quot;</span><span class="p">|</span>sort -k3 -nr

按实际使用内存百分比排序
ps -eo user,pid,size,pmem,vsize,command<span class="p">|</span>sort -k4 -nr<span class="p">|</span>more

查看并发访问用户的前10位
netstat -anp<span class="p">|</span>grep <span class="m">80</span><span class="p">|</span>grep ESTAB<span class="p">|</span>awk <span class="s1">&#39;{print $5}&#39;</span><span class="p">|</span>awk -F <span class="s1">&#39;:&#39;</span> <span class="s1">&#39;{print $1}&#39;</span><span class="p">|</span>sort <span class="p">|</span>uniq -c<span class="p">|</span>sort -rn<span class="p">|</span>head -n <span class="m">10</span>

对cpu访问量高进程排序
ps -eo user,pid,size,pmem,vsize,command,%cpu<span class="p">|</span>sort -k7 -nr<span class="p">|</span>more<span class="sb">`</span>

杀死某一进程,杀死Nginx进程<span class="o">(</span>杀死某一进程<span class="o">)</span>
ps -ef<span class="p">|</span>grep -v grep <span class="p">|</span>grep nginx<span class="p">|</span>awk <span class="s1">&#39;{print $2}&#39;</span>
或
<span class="k">for</span> i in <span class="sb">`</span>ps aux <span class="p">|</span> grep nginx <span class="p">|</span> grep -v grep <span class="p">|</span> awk <span class="o">{</span><span class="s1">&#39;print $2&#39;</span><span class="o">}</span><span class="sb">`</span> <span class="p">;</span> <span class="k">do</span> <span class="nb">kill</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span>

清空Linux Buffer Cache
sync <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="m">3</span> &gt; /proc/sys/vm/drop_caches
</pre></div>

<h3 id="linux_7">Linux中查看所有正在运行的进程<a class="headerlink" href="#linux_7" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>ps aux或ps -ef
任务：查看系统中的每个进程。
ps -A
ps -e
任务：查看非root运行的进程
ps -U root -u root -N
任务：查看用户vivek运行的进程
ps -u vivek
top命令提供了运行中系统的动态实时视图。在命令提示行中输入top：
top
pstree以树状显示正在运行的进程。树的根节点为pid或init。如果指定了用户名，进程树将以用户所拥有的进程作为根节点。
pstree
任务：使用ps列印进程树
ps -ejH
ps axjf
任务：获得线程信息
输入下列命令：
ps -eLf
ps axms
任务：获得安全信息
输入下列命令：
ps -eo euser,ruser,suser,fuser,f,comm,label
ps axZ
ps -eM
任务：将进程快照储存到文件中。输入下列命令：
top -b -n1 &gt; /tmp/process.log
你也可以将结果通过邮件发给自己：
top -b -n1 <span class="p">|</span> mail -s <span class="s1">&#39;Process snapshot&#39;</span> you@example.com
任务：查找进程
使用pgrep命令。pgrep能查找当前正在运行的进程并列出符合条件的进程ID。例如显示firefox的进程ID：
pgrep firefox
下面命令将显示进程名为sshd、所有者为root的进程。
pgrep -u root sshd
</pre></div>

<h3 id="linux-vmware-tools">Linux VMware Tools安装步骤简易版<a class="headerlink" href="#linux-vmware-tools" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="m">1</span>. 在CD-ROM虚拟光驱中选择使用ISO镜像，这个ISO是你安装VMware workstation 的目录下的Linux.iso，不是你的Linux OS 镜像文件。VMware Tools一般都在这个文件里。
<span class="m">2</span>. 以管理员身份进入Linux，root账号
<span class="m">3</span>. 挂载光驱：执行mount /dev/cdrom /mnt/cdrom，这时如果进入/mnt 目录下，你会发现一个文件：VMwareTools-8.8.4-743747.tar.gz 有的虚拟机上估计如果提示如下错误，挂载点不存在。，
mount /dev/cdrom /mnt/cdrom
mount: mount point /mnt/cdrom dose not exist
请直接执行此命令：
mount /dev/cdrom /opt
<span class="nb">cd</span> /opt
或者应该可以使用自动挂载，直接进入
<span class="nb">cd</span> /misc/cd
<span class="m">4</span>. copy 此文件到临时文件夹
cp /mnt/mVMwareTools-8.8.4-743747.tar.gz /tmp
<span class="m">5</span>. 卸载CDROM，执行 umount /dev/cdrom
<span class="m">6</span>. 进入tmp文件目录并解压此文件包
<span class="nb">cd</span> /tmp
tar zxvf vmware-linux-tools.tar.gz
解压默认到vmware-tools-distrib目录下：此时你可以使用ls -ll 查看文件夹下的文件
<span class="m">7</span>. 进入vmware-tools-distrib，安装vmware tools.
./vmware-install.pl  执行安装，
<span class="m">8</span>. 大约5分钟左右安装完成。 执行init 6重启ok。
利用xshell的MODEM传输文件需安装lrzsz
</pre></div>

<h3 id="rm">恢复rm误删的文件<a class="headerlink" href="#rm" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>一、下载及安装软件
extundelete 主页：http://extundelete.sourceforge.net/
下载地址：http://nchc.dl.sourceforge.net/project/extundelete/extundelete/0.2.0/extundelete-0.2.0.tar.bz2
ubuntu用户可直接安装: apt-get install extundelete
./configure <span class="o">&amp;&amp;</span> make <span class="o">&amp;&amp;</span> make install    <span class="c1"># 如果提示找不到ext2fs库，使用 yum -y install e2fsprogs* 安装</span>
二、数据恢复
<span class="m">1</span>.卸载需要恢复文件的分区
fuser -k /mnt/test/               &lt;-- 结束使用某分区的进程树
umount /mnt/test                  &lt;-- 卸载分区
<span class="m">2</span>.使用extundelete查看分区上存在的文件
extundelete --inode <span class="m">2</span> /dev/sdb1    <span class="c1"># --inode 为查找某i节点中的内容，使用2则说明为搜索，如果需要进入目录搜索，只须要指定目录I节点即可</span>
extundelete --restore-inode <span class="m">13</span> /dev/sdb1    <span class="c1"># --restore-inode 恢复指定的I节点文件，默认全将恢复出来的文件放在当前路径 RECOVERED_FILES/ 目录下，文件名为 file.I节点号</span>
ls RECOVERED_FILES/
mount /dev/sdb1 /mnt/test/
mv RECOVERED_FILES/file.13 /mnt/test/resolv.conf
mv RECOVERED_FILES/file.14 /mnt/test/hosts
cat /mnt/test/hosts            <span class="c1"># 查看被恢复出来的文件 是否与源文件一致</span>
cat /mnt/test/resolv.conf
</pre></div>

<h3 id="linux_8">linux常用日志文件默认路径<a class="headerlink" href="#linux_8" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>IP登录日志默认路径：/var/log/wtmp
命令：last -f /var/log/wtmp
</pre></div>

<h3 id="1gswap">增加1G的swap空间<a class="headerlink" href="#1gswap" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="c1">#创建1G文件</span>
dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>/opt/swap <span class="nv">bs</span><span class="o">=</span>1k <span class="nv">count</span><span class="o">=</span><span class="m">1024000</span>
mkswap /opt/swap    <span class="c1"># 将创建的文件用作交换分区</span>
swapon /opt/swap    <span class="c1"># 开启swap</span>
</pre></div>

<h3 id="linux_9">Linux备份<a class="headerlink" href="#linux_9" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>系统的潜在威胁
<span class="m">1</span>，系统硬件故障
<span class="m">2</span>，软件故障
<span class="m">3</span>，电源故障
<span class="m">4</span>，用户的误操作
<span class="m">5</span>，人为破坏
<span class="m">6</span>，缓存中的内容没有及时的写入磁盘
<span class="m">7</span>，自然灾害

备份介质的选择：
硬盘（文件存储服务器），光盘，磁带机，可移动存储设备；
备注：一般在选择备份介质时，要从可靠性，速度和介质价格之间进行权衡；

Linux备份策略：

<span class="m">1</span>.完全备份
    每隔一段时间对系统进行一次完全的备份，这样在备份时间间隔内，一旦系统发生了故障使得数据丢失时，就可以用上一次的备份数据恢复得到上一次备份时的情况。

<span class="m">2</span>.增量备份:
     首先进行一次完全备份，然后每隔一段较短的时间进行一次备份，但是仅仅备份每个短时间内更改或者更新的内容。

备份过程中考虑的因素：
<span class="m">1</span>，备份
<span class="m">2</span>，备份分区，ro,umount直接不挂载；
<span class="m">3</span>, 压缩 bzip2
<span class="m">4</span>, 校验 md5sum -c
<span class="m">5</span>, 加密 GnupG

备份常用的指令：
备份目录：cp -Rpu 备份目录  目标目录
-p保持备份目录及文件的属性（默认的属性）
-u增量备份；

案例:
mount -o remount,ro /backup
cp /etc/inittab /backup/inittab_20130511.bak <span class="c1">#出现报错信息；</span>
mount -o  remount,rw /backup#解决问题的命令，亦可读写的方式挂载；

<span class="c1">#远程备份可用SCP命令；</span>

tar备份命令：
首先，备份/etc目录，可同时打包多个目录
tar -zcf /backup/sys_20130510.tar.gz /etc /boot

如何对/etc目录下指定文件进行备份？
tar -zcf backup_user_20130510.tar.gz /etc/passed /etc/shadow /etc/group /etc/gshadow

如何查看查看备份包文件？
tar -ztf /backup/user_20130510.tar.gz

如何恢复/etc目录？
tar -zxf /backup/sys_20130510.tar.gz
备注：默认还原到打包文件源目录，-C选项可以指定具体的还原目录；

只恢复备份中的指定文件
tar -zxf backup_user_20130510.tar.gz /etc/passwd

备注：在备份过程中添加时间值是非常有必要额；
</pre></div>

<h3 id="linux_10">Linux测试硬盘读写速度<a class="headerlink" href="#linux_10" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>time有计时作用，dd用于复制，从if读出，写到of。if<span class="o">=</span>/dev/zero不产生IO，因此可以用来测试纯写速度。同理of<span class="o">=</span>/dev/null不产生IO，可以用来测试纯读速度。bs是每次读或写的大小，即一个块的大小，count是读写块的数量。

<span class="m">1</span>.测/目录所在磁盘的纯写速度：
<span class="nb">time</span> dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">bs</span><span class="o">=</span><span class="m">1024</span> <span class="nv">count</span><span class="o">=</span><span class="m">1000000</span> <span class="nv">of</span><span class="o">=</span>/1Gb.file

<span class="m">2</span>.测/目录所在磁盘的纯读速度：
dd <span class="k">if</span><span class="o">=</span>/kvm/ftp/other/1Gb.file <span class="nv">bs</span><span class="o">=</span>64k <span class="p">|</span>dd <span class="nv">of</span><span class="o">=</span>/dev/null

<span class="m">3</span>.测读写速度（这是什么）：
dd <span class="k">if</span><span class="o">=</span>/vat/test <span class="nv">of</span><span class="o">=</span>/oradata/test1 <span class="nv">bs</span><span class="o">=</span>64k

理论上复制量越大测试越准确。
</pre></div>

<h3 id="8">获取8位随机字符串<a class="headerlink" href="#8" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>方法一：echo <span class="nv">$RANDOM</span> <span class="p">|</span>md5sum <span class="p">|</span>cut -c <span class="m">1</span>-8
方法二：openssl rand -base64 <span class="m">4</span>
方法三：cat /proc/sys/kernel/random/uuid <span class="p">|</span>cut -c <span class="m">1</span>-8
</pre></div>

<h3 id="8_1">获取8位随机数字<a class="headerlink" href="#8_1" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>方法一：echo <span class="nv">$RANDOM</span> <span class="p">|</span>cksum <span class="p">|</span>cut -c <span class="m">1</span>-8
方法二：openssl rand -base64 <span class="m">4</span> <span class="p">|</span>cksum <span class="p">|</span>cut -c <span class="m">1</span>-8
方法三：date +%N <span class="p">|</span>cut -c <span class="m">1</span>-8
cksum:打印CRC校检和统计字节
</pre></div>

<h3 id="_15">定义一个颜色输出字符串函数<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>方法一：
<span class="k">function</span> echo_color<span class="o">(){</span>
 <span class="k">if</span> <span class="o">[</span><span class="nv">$1</span> <span class="o">==</span> <span class="s2">&quot;green&quot;</span><span class="o">]</span><span class="p">;</span><span class="k">then</span>
  <span class="nb">echo</span> -e <span class="s2">&quot;\033[32;40m</span><span class="nv">$2</span><span class="s2">\033[0m&quot;</span>
 <span class="k">elif</span> <span class="o">[</span><span class="nv">$1</span> <span class="o">==</span> <span class="s2">&quot;red&quot;</span><span class="m">0</span><span class="o">]</span><span class="p">;</span><span class="k">then</span>
  <span class="nb">echo</span> -e <span class="s2">&quot;\\033[31;40m</span><span class="nv">$2</span><span class="s2">\033[0m&quot;</span>
 <span class="k">fi</span>
<span class="o">}</span>

方法二：
<span class="k">function</span> echo_color<span class="o">(){</span>
 <span class="k">case</span> <span class="nv">$1</span> in
  green<span class="o">)</span>
   <span class="nb">echo</span> -e <span class="s2">&quot;\033[32;40m</span><span class="nv">$2</span><span class="s2">\033[0m&quot;</span>
   <span class="p">;;</span>
  red<span class="o">)</span>
   <span class="nb">echo</span> -e <span class="s2">&quot;\033[31;40m</span><span class="nv">$2</span><span class="s2">\033[0m&quot;</span>
   <span class="p">;;</span>
  *<span class="o">)</span>
   <span class="nb">echo</span> <span class="s2">&quot;Example:echo_color red string&quot;</span>
  <span class="k">esac</span>
<span class="o">}</span>
function关键字定义一个函数，可加或不加。
</pre></div>

<h3 id="_16">批量创建用户<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="nv">DATE</span><span class="o">=</span><span class="k">$(</span>date+%F_%T<span class="k">)</span>
<span class="nv">USER_FILE</span><span class="o">=</span>user.txt
echo_color<span class="o">(){</span>
 <span class="k">if</span> <span class="o">[</span><span class="nv">$1</span> <span class="o">==</span> <span class="s2">&quot;green&quot;</span><span class="o">]</span><span class="p">;</span><span class="k">then</span>
  <span class="nb">echo</span> -e <span class="s2">&quot;\033[32;40m</span><span class="nv">$2</span><span class="s2">\033[0m&quot;</span>
 <span class="k">elif</span> <span class="o">[</span><span class="nv">$1</span> <span class="o">==</span> <span class="s2">&quot;red&quot;</span><span class="m">0</span><span class="o">]</span><span class="p">;</span><span class="k">then</span>
  <span class="nb">echo</span> -e <span class="s2">&quot;\\033[31;40m</span><span class="nv">$2</span><span class="s2">\033[0m&quot;</span>
 <span class="k">fi</span>
<span class="o">}</span>
<span class="c1"># 如果用户文件存在并大于0就备份</span>
 <span class="k">if</span> <span class="o">[</span>-s <span class="nv">$USER_FILE</span><span class="o">]</span><span class="p">;</span><span class="k">then</span>
  mv <span class="nv">$USER_FILE</span> <span class="si">${</span><span class="nv">USER_FILE</span><span class="si">}</span>-<span class="si">${</span><span class="nv">DATE</span><span class="si">}</span>.bak
  echo_color green <span class="s2">&quot;</span><span class="nv">$USER_FILE</span><span class="s2"> exist,rename </span><span class="si">${</span><span class="nv">USER_FILE</span><span class="si">}</span><span class="s2">-</span><span class="si">${</span><span class="nv">DATE</span><span class="si">}</span><span class="s2">.bak&quot;</span>
 <span class="k">fi</span>
 <span class="nb">echo</span>
</pre></div>

<h3 id="bash">简单检测某个进程是否存在的bash小脚本。代码如下<a class="headerlink" href="#bash" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="nv">ps_out</span><span class="o">=</span><span class="sb">`</span>ps -ef <span class="p">|</span> grep <span class="nv">$1</span> <span class="p">|</span> grep -v <span class="s1">&#39;grep&#39;</span> <span class="p">|</span> grep -v <span class="nv">$0</span><span class="sb">`</span>
<span class="nv">result</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$ps_out</span> <span class="p">|</span> grep <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span><span class="k">)</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$result</span><span class="s2">&quot;</span> !<span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="o">]]</span><span class="p">;</span><span class="k">then</span>
 <span class="nb">echo</span> <span class="s2">&quot;Running&quot;</span>
<span class="k">else</span>
 <span class="nb">echo</span> <span class="s2">&quot;Not Running&quot;</span>
<span class="k">fi</span>
举例使用
比如我们启动了进程SimpleHTTPServer,我们想检测这个进程是否存在，可以这样。
代码如下:
<span class="c1"># ./checkRunningProcess.sh &#39;SimpleHTTPServer&#39; Running</span>
</pre></div>

<h3 id="shell_1">shell变量的子串的删除/替换<a class="headerlink" href="#shell_1" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="si">${#</span><span class="nv">string</span><span class="si">}</span>返回<span class="nv">$string的长度</span>
<span class="si">${</span><span class="nv">string</span><span class="p">:</span><span class="nv">position</span><span class="si">}</span>在<span class="nv">$string中</span>，从<span class="nv">$position位置之后开始提取子串</span>
<span class="si">${</span><span class="nv">string</span><span class="p">:</span><span class="nv">position</span><span class="p">:</span><span class="nv">length</span><span class="si">}</span>在<span class="nv">$string中</span>，从<span class="nv">$position位置之后开始提取$length长度的子串</span>
<span class="si">${</span><span class="nv">string</span><span class="p">#substring</span><span class="si">}</span>从变量<span class="nv">$string开头开始删除最短匹配$substring子串</span>
<span class="si">${</span><span class="nv">string</span><span class="p">##substring</span><span class="si">}</span>从变量<span class="nv">$string开头开始删除最长匹配$sunstring子串</span>
<span class="si">${</span><span class="nv">string</span><span class="p">%substring</span><span class="si">}</span>从变量<span class="nv">$string结尾开始删除最短匹配$substring子串</span>
<span class="si">${</span><span class="nv">string</span><span class="p">%%substring</span><span class="si">}</span> 从变量<span class="nv">$string结尾开始删除最长匹配$substring子串</span>
注意：在进行#或##匹配时，<span class="nv">$string的首字符必须是被删除子串$substring的第一个字符</span>，不然无法匹配删除；
在进行%或者%%匹配时，<span class="nv">$string的最后一个字符必须是被删除子串$substring的最后一个字符</span>，不然无法进行删除操作；
<span class="si">${</span><span class="nv">parameter</span><span class="p">/parttern/string</span><span class="si">}</span> 用string来替换第一个匹配的pattern
<span class="si">${</span><span class="nv">parameter</span><span class="p">/#parttern/string</span><span class="si">}</span> 从开头匹配parameter变量中的pattern，匹配上后就用string来替换匹配的pattern
<span class="si">${</span><span class="nv">parameter</span><span class="p">/%pattern/string</span><span class="si">}</span> 从结尾开始匹配parameter变量中的pattern，匹配上后就用string替换匹配的pattern
<span class="si">${</span><span class="nv">parameter</span><span class="p">//pattern/string</span><span class="si">}</span> 用string来替换parameter变量中所有匹配的pattern
</pre></div>

<h3 id="5">清除大于5天的文件<a class="headerlink" href="#5" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="ch">#!/bin/sh</span>
find /usr/local/tomcat/logs -name <span class="s1">&#39;catalina.*.log&#39;</span> -mtime +5 -print0 <span class="p">|</span> xargs -0 rm -f
find /usr/local/tomcat/logs -name <span class="s1">&#39;localhost_access_log.*.txt&#39;</span> -mtime +5 -print0 <span class="p">|</span> xargs -0 rm -f
</pre></div>

<h3 id="shellcpu">shell采集系统cpu 内存 磁盘 网络信息<a class="headerlink" href="#shellcpu" title="Permanent link">&para;</a></h3>
<h3 id="cpu">cpu信息采集<a class="headerlink" href="#cpu" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>cpu使用率采集算法
通过/proc/stat文件采集并计算CPU总使用率或者单个核使用率。以cpu0为例，算法如下：
<span class="m">1</span>. cat /proc/stat <span class="p">|</span> grep ‘cpu0’得到cpu0的信息
<span class="m">2</span>. <span class="nv">cpuTotal1</span><span class="o">=</span>user+nice+system+idle+iowait+irq+softirq
<span class="m">3</span>. <span class="nv">cpuUsed1</span><span class="o">=</span>user+nice+system+irq+softirq
<span class="m">4</span>. sleep 30秒
<span class="m">5</span>. 再次cat /proc/stat <span class="p">|</span> grep ‘cpu0’ 得到cpu的信息
<span class="m">6</span>. <span class="nv">cpuTotal2</span><span class="o">=</span>user+nice+system+idle+iowait+irq+softirq
<span class="m">7</span>. <span class="nv">cpuUsed2</span><span class="o">=</span>user+nice+system+irq+softirq
<span class="m">8</span>. 得到cpu0 在30秒内的单核利用率：<span class="o">(</span>cpuUsed2 – cpuUsed1<span class="o">)</span> * <span class="m">100</span> / <span class="o">(</span>cpuTotal2 – cpuTotal1<span class="o">)</span>
相当于使用top –d 30命令，把user、nice、system、irq、softirq五项的使用率相加。

shell代码：

<span class="nv">a</span><span class="o">=(</span><span class="sb">`</span>cat /proc/stat <span class="p">|</span> grep -E <span class="s2">&quot;cpu\b&quot;</span> <span class="p">|</span> awk -v <span class="nv">total</span><span class="o">=</span><span class="m">0</span> <span class="s1">&#39;{$1=&quot;&quot;;for(i=2;i&lt;=NF;i++){total+=$i};used=$2+$3+$4+$7+$8 }END{print total,used}&#39;</span><span class="sb">`</span><span class="o">)</span>
sleep <span class="m">30</span>
<span class="nv">b</span><span class="o">=(</span><span class="sb">`</span>cat /proc/stat <span class="p">|</span> grep -E <span class="s2">&quot;cpu\b&quot;</span> <span class="p">|</span> awk -v <span class="nv">total</span><span class="o">=</span><span class="m">0</span> <span class="s1">&#39;{$1=&quot;&quot;;for(i=2;i&lt;=NF;i++){total+=$i};used=$2+$3+$4+$7+$8 }END{print total,used}&#39;</span><span class="sb">`</span><span class="o">)</span>
<span class="nv">cpu_usage</span><span class="o">=(((</span><span class="si">${</span><span class="nv">b</span><span class="p">[1]</span><span class="si">}</span>-<span class="si">${</span><span class="nv">a</span><span class="p">[1]</span><span class="si">}</span><span class="o">)</span>*100/<span class="o">(</span><span class="si">${</span><span class="nv">b</span><span class="p">[0]</span><span class="si">}</span>-<span class="si">${</span><span class="nv">a</span><span class="p">[0]</span><span class="si">}</span><span class="o">)))</span>

cpu负载
采集算法：
读取/proc/loadavg得到机器的1/5/15分钟平均负载，再乘以100。

shell代码：

<span class="nv">cpuload</span><span class="o">=(</span><span class="sb">`</span>cat /proc/loadavg <span class="p">|</span> awk <span class="s1">&#39;{print $1,$2,$3}&#39;</span><span class="sb">`</span><span class="o">)</span>
<span class="nv">load1</span><span class="o">=</span><span class="si">${</span><span class="nv">cpuload</span><span class="p">[0]</span><span class="si">}</span>
<span class="nv">load5</span><span class="o">=</span><span class="si">${</span><span class="nv">cpuload</span><span class="p">[1]</span><span class="si">}</span>
<span class="nv">load15</span><span class="o">=</span><span class="si">${</span><span class="nv">cpuload</span><span class="p">[2]</span><span class="si">}</span>
</pre></div>

<h3 id="_17">内存采集<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>应用程序使用内存采集算法：
读取/proc/meminfo文件，<span class="o">(</span>MemTotal – MemFree – Buffers – Cached<span class="o">)</span>/1024得到应用程序使用内存数。

shell代码：

awk <span class="s1">&#39;/MemTotal/{total=$2}/MemFree/{free=$2}/Buffers/{buffers=$2}/^Cached/{cached=$2}END{print (total-free-buffers-cached)/1024}&#39;</span>  /proc/meminfo

MEM使用量采集算法：
读取/proc/meminfo文件，MemTotal – MemFree得到MEM使用量。

shell代码：

awk <span class="s1">&#39;/MemTotal/{total=$2}/MemFree/{free=$2}END{print (total-free)/1024}&#39;</span>  /proc/meminfo

SWAP使用大小采集算法：
通过/proc/meminfo文件，SwapTotal – SwapFree得到SWAP使用大小。

shell代码：

awk <span class="s1">&#39;/SwapTotal/{total=$2}/SwapFree/{free=$2}END{print (total-free)/1024}&#39;</span>  /proc/meminfo
</pre></div>

<h3 id="_18">磁盘信息采集<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>disk io

<span class="m">1</span>、IN：平均每秒把数据从硬盘读到物理内存的数据量
采集算法：
读取/proc/vmstat文件得出最近240秒内pgpgin的增量，把pgpgin的增量再除以240得到每秒的平均增量。
相当于vmstat 240命令bi一列的输出。

shell代码：

<span class="nv">a</span><span class="o">=</span><span class="sb">`</span>awk <span class="s1">&#39;/pgpgin/{print $2}&#39;</span> /proc/vmstat<span class="sb">`</span>
sleep <span class="m">240</span>
<span class="nv">b</span><span class="o">=</span><span class="sb">`</span>awk <span class="s1">&#39;/pgpgin/{print $2}&#39;</span> /proc/vmstat<span class="sb">`</span>
<span class="nv">ioin</span><span class="o">=</span><span class="k">$((</span><span class="o">(</span>b-a<span class="o">)/</span><span class="m">240</span><span class="k">))</span>

<span class="m">2</span>、OUT：平均每秒把数据从物理内存写到硬盘的数据量
采集算法：
读取/proc/vmstat文件得出最近240秒内pgpgout的增量，把pgpgout的增量再除以240得到每秒的平均增量。
相当于vmstat 240命令bo一列的输出。

shell代码：

<span class="nv">a</span><span class="o">=</span><span class="sb">`</span>awk <span class="s1">&#39;/pgpgout/{print $2}&#39;</span> /proc/vmstat<span class="sb">`</span>
sleep <span class="m">240</span>
<span class="nv">b</span><span class="o">=</span><span class="sb">`</span>awk <span class="s1">&#39;/pgpgout/{print $2}&#39;</span> /proc/vmstat<span class="sb">`</span>
<span class="nv">ioout</span><span class="o">=</span><span class="k">$((</span><span class="o">(</span>b-a<span class="o">)/</span><span class="m">240</span><span class="k">))</span>
</pre></div>

<h3 id="_19">网络信息采集<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>流量

以https://www.centos.bz/为例，eth0是内网，eth1外网，获取60秒的流量。
机器网卡的平均每秒流量
采集算法：
读取/proc/net/dev文件，得到60秒内发送和接收的字节数（KB），然后乘以8，再除以60，得到每秒的平均流量。

shell代码：

<span class="nv">traffic_be</span><span class="o">=(</span><span class="sb">`</span>awk -F<span class="s1">&#39;[: ]+&#39;</span> <span class="s1">&#39;BEGIN{ORS=&quot; &quot;}/eth0/{print $3,$10}/eth1/{print $3,$11}&#39;</span> /proc/net/dev<span class="sb">`</span><span class="o">)</span>
sleep <span class="m">60</span>
<span class="nv">traffic_af</span><span class="o">=(</span><span class="sb">`</span>awk -F<span class="s1">&#39;[: ]+&#39;</span> <span class="s1">&#39;BEGIN{ORS=&quot; &quot;}/eth0/{print $3,$10}/eth1/{print $3,$11}&#39;</span> /proc/net/dev<span class="sb">`</span><span class="o">)</span>
<span class="nv">eth0_in</span><span class="o">=</span><span class="k">$((</span> <span class="o">(</span><span class="si">${</span><span class="nv">traffic_af</span><span class="p">[0]</span><span class="si">}</span><span class="o">-</span><span class="si">${</span><span class="nv">traffic_be</span><span class="p">[0]</span><span class="si">}</span><span class="o">)/</span><span class="m">60</span> <span class="k">))</span>
<span class="nv">eth0_out</span><span class="o">=</span><span class="k">$((</span> <span class="o">(</span><span class="si">${</span><span class="nv">traffic_af</span><span class="p">[1]</span><span class="si">}</span><span class="o">-</span><span class="si">${</span><span class="nv">traffic_be</span><span class="p">[1]</span><span class="si">}</span><span class="o">)/</span><span class="m">60</span> <span class="k">))</span>
<span class="nv">eth1_in</span><span class="o">=</span><span class="k">$((</span> <span class="o">(</span><span class="si">${</span><span class="nv">traffic_af</span><span class="p">[2]</span><span class="si">}</span><span class="o">-</span><span class="si">${</span><span class="nv">traffic_be</span><span class="p">[2]</span><span class="si">}</span><span class="o">)/</span><span class="m">60</span> <span class="k">))</span>
<span class="nv">eth1_out</span><span class="o">=</span><span class="k">$((</span> <span class="o">(</span><span class="si">${</span><span class="nv">traffic_af</span><span class="p">[3]</span><span class="si">}</span><span class="o">-</span><span class="si">${</span><span class="nv">traffic_be</span><span class="p">[3]</span><span class="si">}</span><span class="o">)/</span><span class="m">60</span> <span class="k">))</span>

包量

机器网卡的平均每秒包量
采集算法：
读取/proc/net/dev文件，得到60秒内发送和接收的包量，然后除以60，得到每秒的平均包量。

shell代码：

<span class="nv">packet_be</span><span class="o">=(</span><span class="sb">`</span>awk -F<span class="s1">&#39;[: ]+&#39;</span> <span class="s1">&#39;BEGIN{ORS=&quot; &quot;}/eth0/{print $4,$12}/eth1/{print $4,$12}&#39;</span> /proc/net/dev<span class="sb">`</span><span class="o">)</span>
sleep <span class="m">60</span>
<span class="nv">packet_af</span><span class="o">=(</span><span class="sb">`</span>awk -F<span class="s1">&#39;[: ]+&#39;</span> <span class="s1">&#39;BEGIN{ORS=&quot; &quot;}/eth0/{print $4,$12}/eth1/{print $4,$12}&#39;</span> /proc/net/dev<span class="sb">`</span><span class="o">)</span>
<span class="nv">eth0_in</span><span class="o">=</span><span class="k">$((</span> <span class="o">(</span><span class="si">${</span><span class="nv">packet_af</span><span class="p">[0]</span><span class="si">}</span><span class="o">-</span><span class="si">${</span><span class="nv">packet_be</span><span class="p">[0]</span><span class="si">}</span><span class="o">)/</span><span class="m">60</span> <span class="k">))</span>
<span class="nv">eth0_out</span><span class="o">=</span><span class="k">$((</span> <span class="o">(</span><span class="si">${</span><span class="nv">packet_af</span><span class="p">[1]</span><span class="si">}</span><span class="o">-</span> <span class="si">${</span><span class="nv">packet_be</span><span class="p">[1]</span><span class="si">}</span><span class="o">)/</span><span class="m">60</span> <span class="k">))</span>
<span class="nv">eth1_in</span><span class="o">=</span><span class="k">$((</span> <span class="o">(</span><span class="si">${</span><span class="nv">packet_af</span><span class="p">[2]</span><span class="si">}</span><span class="o">-</span> <span class="si">${</span><span class="nv">packet_be</span><span class="p">[2]</span><span class="si">}</span><span class="o">)/</span><span class="m">60</span> <span class="k">))</span>
<span class="nv">eth1_out</span><span class="o">=</span><span class="k">$((</span> <span class="o">(</span><span class="si">${</span><span class="nv">packet_af</span><span class="p">[3]</span><span class="si">}</span><span class="o">-</span> <span class="si">${</span><span class="nv">packet_be</span><span class="p">[3]</span><span class="si">}</span><span class="o">)/</span><span class="m">60</span> <span class="k">))</span>
</pre></div>

<div class="codehilite"><pre><span></span><span class="ch">#!/bin/sh</span>
<span class="c1">#</span>
<span class="c1"># ShowTuxPerf</span>
<span class="c1"># A simple SH to display PC performance on a Linux OS</span>
<span class="c1">#</span>
<span class="c1"># Syntaxe: sudo ./showtuxperf.sh</span>
<span class="c1">#</span>
<span class="c1"># Nicolas Hennion -GPL</span>
<span class="c1">#</span>
<span class="nv">VERSION</span><span class="o">=</span><span class="s2">&quot;0.1&quot;</span>
dmidecode -s system-product-name
dmidecode -s system-version
lscpu - cat /proc/cpuinfo
lspci <span class="p">|</span> grep VGA
uname -a
</pre></div>

<h3 id="shell_2">系统管理的常用shell命令<a class="headerlink" href="#shell_2" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>显示消耗内存/CPU最多的十个进程
ps aux <span class="p">|</span> sort -nk +4 <span class="p">|</span> tail
ps aux <span class="p">|</span> sort -nk +3 <span class="p">|</span> tail

查看linux服务器物理CPU的个数
cat /proc/cpuinfo <span class="p">|</span> grep <span class="s2">&quot;physical id&quot;</span> <span class="p">|</span> sort <span class="p">|</span> uniq  <span class="p">|</span> wc -l

查看linux服务器逻辑CPU的个数
cat /proc/cpuinfo <span class="p">|</span> grep <span class="s2">&quot;processor &quot;</span> <span class="p">|</span> wc -l

精简开机启动服务器
<span class="k">for</span> server in <span class="sb">`</span>chkconfig --list<span class="p">|</span>egrep -v <span class="s1">&#39;crond|network|rsyslog|sshd|iptables&#39;</span><span class="p">|</span>awk <span class="s1">&#39;{print $1}&#39;</span><span class="sb">`</span><span class="p">;</span><span class="k">do</span> chkconfig <span class="nv">$server</span> off<span class="p">;</span> <span class="k">done</span>
关闭selinux
sed -i <span class="s1">&#39;s/SELINUX=enforcing/SELINUX=disabled/&#39;</span> /etc/selinux/config
setenforce <span class="m">0</span>

禁止root用户远程登录
sed -i <span class="s1">&#39;s/#PermitRootLogin yes/PermitRootLogin no/&#39;</span> /etc/ssh/sshd_config

修改最大连接数 ulimit（方法不只一种）
<span class="nb">echo</span> <span class="s1">&#39;* - noproc 65535&#39;</span> &gt;&gt; /etc/security/limits.conf

<span class="nb">echo</span> <span class="s1">&#39;* - nofile 65535&#39;</span> &gt;&gt; /etc/security/limits.conf

修改默认DNS
<span class="nb">echo</span> <span class="s2">&quot;nameserver 8.8.8.8&quot;</span> &gt; /etc/resolv.conf
<span class="nb">echo</span> <span class="s2">&quot;nameserver 8.8.4.4&quot;</span> &gt;&gt; /etc/resolv.conf

去除上次登录的信息
touch ~/.hushlogin

禁止使用Ctrl+Alt+Del快捷键重启服务器
方法一：
      sed -i <span class="s2">&quot;s/start on control-alt-delete/#start on control-alt-delete/g&quot;</span>                   /etc/init/control-alt-delete.conf
方法二：
      vim /etc/inittab
      <span class="c1">#ca::ctrlaltdel:/sbin/shutdown -t3 -r now</span>
      init q  （使用此命令使之生效<span class="o">)</span>

限制用户登录的tty终端
vim /etc/inittab   （在tty终端前加#号，注释掉就可以）

禁止root用户登录的终端
vim /etc/securetty （加#号注释）


禁止除root外的用户从tty1终端登录系统
①   vim /etc/pam.d/login
Account  required  pam_access.so  <span class="o">(</span>增加此认证<span class="o">)</span>
②   vim /etc/security/access.conf
-:ALL EXCEPT root:tty1  <span class="o">(</span>去掉#号<span class="o">)</span>
- : root : <span class="m">192</span>.168.12.0/24  <span class="m">172</span>.16.0.0/8（禁止root用户从这两个网段远程登录）
</pre></div>

<div class="codehilite"><pre><span></span>top -d <span class="m">1</span> -n <span class="m">1</span> -b <span class="p">|</span>awk -F <span class="s1">&#39;[ ,.%k]+&#39;</span> <span class="s1">&#39;/^Cpu/{printf &quot;UPU_USAGE %.f%%\t&quot;,100-$11}/^Mem/{printf &quot;MEM_USAGE %.f%%\n&quot;,($4-$8)/$2*100}&#39;</span>
top -d <span class="m">1</span> -n <span class="m">1</span> -b <span class="p">|</span>awk -F <span class="s1">&#39;[ ,.%k]+&#39;</span> <span class="s1">&#39;/^Cpu/{printf &quot;CPU_USAGE %.f%%\t&quot;,100-$11}/^Mem/{printf &quot;MEM_USAGE %.f%%\t&quot;,($4-$8)/$2*100;now=strftime(&quot;%D %T&quot;);print now}&#39;</span>
</pre></div>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../Go/" title="Go" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  后退
                </span>
                Go
              </span>
            </div>
          </a>
        
        
          <a href="../Utilities/" title="Iproute2&Net-tools" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  前进
                </span>
                Iproute2&Net-tools
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="../assets/fonts/font-awesome.css">
    
      <a href="https://github.com/Black-Gold" class="md-footer-social__link fa fa-github"></a>
    
      <a href="https://www.instagram.com/black0gold/" class="md-footer-social__link fa fa-instagram"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.b806dc00.js"></script>
      
        
        
          
          <script src="../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
                <script src="../assets/javascripts/lunr/tinyseg.js"></script>
              
              
                <script src="../assets/javascripts/lunr/lunr.jp.js"></script>
              
            
          
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:".."}})</script>
      
    
  </body>
</html>